---
title: DNS란?
tags: 네트워크
article_header:
type: cover
---

# DNS

---

**DNS(Domain Name Server)** 는 **IP주소**와 **도메인 이름**을 상호교환 하게 해주는 프로토콜입니다.

이 프로토콜을 사용하는 이유는 사람은 긴 IP주소를 매번 기억하고 사용하는 것이 번거롭기 때문에 **IP**에 이름을 지정하고
**IP**대신 **도메인 이름**을 사용하기 위해서 **DNS**를 이용합니다.

예를들어 **172.217.175.4**라는 구글 웹서버에 접속하기 위해서 매번 사용자가 **IP**를 주소창에 입력하는 것은 어려운 작업일
것입니다.
그렇기 때문에 **www.google.com**을 입력해도 **172.217.175.4**로 변환되는 기능을 **DNS**가 수행합니다.

<br>
<br>

## 도메인 이름

---

도메인 이름은 **www.google.com** 처럼 **.(dot)** 을 이용하여 구분합니다. 문자 하나당 **라벨**이라고 부르며,
이러한 전체 도메인을 **FQDN(Fully Qualified Domain Name)**이라고 명칭합니다.
크게 **호스트**부분과 **도메인**부분으로 나누게 됩니다.

**호스트**부분은 가장 왼쪽에 있는 라벨로 컴퓨터 그자체를 의미합니다.

**도메인**부분은 크게 3가지로 분리 됩니다.

<br>

### 1. TLD(Top Level Domain)

---

도메인은 높은 계층일수록 우측에 존재하며 가장 높은 수준의 도메인을 **TLD**라고 명칭합니다.

**TLD**는 종류에 따라서 **ccTLD**와 **gTLD**로 나눠지게 됩니다.

**ccTLD**는 국가 코드를 도메인으로 쓰는 탑레벨 도메인입니다. 예시로는 한국은 **kr**, 일본은 **jp** 미국은 **us**가
있습니다.

**gTLD**는 분야별로 나뉘는 탑레벨 도메인입니다. 커머셜 사이트를 나타내는 **com**, 네트워크를 나타내는 **net**등이 있습니다.

<br>
<br>

### 세컨드 레벨 도메인

---

**세컨드 레벨 도메인**은 탑레벨 도메인 좌측에 나오는 도메인이며 대표적으로 **naver**, **google**, **facebook**
등이 있습니다.

<br>
<br>

### 서드 레벨 도메인

---

**써드 레벨 도메인**은 세컨드 레벨 도메인 좌측에 나오며, **dev**, **api**, **example**등 서브 도메인을 명시하는게
주로 사용됩니다.

**서드 레벨 도메인**이 **세컨드 레벨 도메인**이듯이 **세컨드 레벨 도메인**도 **탑 레벨 도메인**의 서브도메인 이라고 할수있습니다.

<br>
<br>

# DNS의 이름결정

---

**IP 주소**와 **도메인 이름**을 서로 교환하는 과정을 **이름 결정**이라고 부릅니다. **DNS**자체만 이용할 수 없고, **DNS
클라이언트**, **캐시 서버**, **권위 서버**등이 서로 연계합니다.

<br>

## DNS 클라이언트(stub resolver)

---

웹 브라우저나, 메일 소프트웨어, 그리고 linux 기준 dig 명령어가 이에 해당합니다.

**DNS 클라이언트**는 캐시 서버에 대해 이름 결정 요청을 송신합니다. 그리고 캐시 서버로부터 받은 응답의 결과를 일정 시간 **캐시**해
두고
같은 요청이 들어왔을때 이를 사용합니다.

<br>
<br>

## 캐시 서버(full service resolver)

---

캐시 서버는 **DNS 클라이언트**로 부터 재귀 쿼리를 받아, 인터넷상에 있는 권위 서버로 이름 결정 **반복 쿼리**를 송신합니다.
캐시 서버도 **DNS 클라이언트**와 마찬가지로 권위 서버로 부터 받은 요청을 캐싱해두고 이를 재이용합니다.

<br>
<br>

## 권위 서버(content server)

---

권위서버는 캐시 서버로부터 **반복 쿼리**를 받아들이는 **DNS 서버**입니다.

인터넷상의 권위 서버는 **루트 서버**라고 불리는 최상위 서버로 부터 트리 형태로 내려오게 됩니다.

이전에 캐시 서버가 요청을 **www.google.com**으로 요청했다고 가정하면, 먼저 **루트 서버**는 **com** 도메인 서버로
요청을 보내게 캐시서버에 요청합니다.

그럼 캐시 서버는 **com** 으로가서 **www.google.com**의 주소를 요청하고, **com** 도메인 서버는 **google**
도메인 서버로 요청을 보내라고 알려줍니다.

**google** 도메인 서버는 **www.google.com**의 주소를 알고 있기 때문에 **IP**를 돌려주고 **반복 쿼리**가
종료됩니다.

아래는 전체 과정에 대한 그림입니다.

<br>
<br>

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Network/study/2주차/재귀쿼리와반복쿼리.png" width="600" height="500" alt="">

<br>
<br>

### DNS 통신과정에서 UDP 사용하는 이유?

---

**이름 결정** 웹 엑세스 혹은 어플리케이션 통신에 앞서 수행됩니다. 그렇기 떄문에 **이름 결정**에서 많은 시간을 소모하게 되면,
그 이후 어플리케이션 통신또한 모두 지연됩니다. 그래서 **이름 결정**은 **UDP**를 사용해 처리 속도를 우선합니다.

<br>
<br>

## DNS 레코드란?

---


**DNS 레코드**는 DNS 서버가 해당 패킷을 받았을 때 어떤식으로 처리할지 나타내는 지침이다.

대표적인 레코드는 아래와 같다.

| 리소스 레코드   | 내용                                                      |
|-----------|---------------------------------------------------------|
| A 레코드     | 도메인 이름에 대응하는 IPv4 주소가 기술된 리소스 레코드                       |
| AAAA 레코드  | 도메인 이름에 대응하는 IPv6 주소가 기술된 리소스 레코드                       |
| NS 레코드    | 도메인을 관리하고 있는 DNS 서버, 또는 관리를 위임하고 있는 DNS 서버가 기술된 리소스 레코드 |
| CNAME 레코드 | 호스트 이름의 별명이 기술된 리소스 레코드                                 |

<br>
<br>
<br>
<br>

출처: 그림으로 공부하는 TCP/IP 구조
