---
title: 무상태성에서 상태를 관리하는 법
tags: 네트워크
article_header:
type: cover
---

# 무상태성?
---

웹은 기본적으로 **Stateless**이다. 즉 무상태성을 이용한다. 무상태성을 사용함으로써 서버는 매번 클라이언트와 연결을 유지하지 않아도 된다는 장점이 있다.

하지만, 로그인이 되어있는 것과 같이 상태를 관리하기 위한 경우가 필요한데 그런경우에 **쿠키**, **세션**, **JWT**를 이용할 수 있다.

<br>
<br>

## 쿠키란?

---

쿠키는 **무상태성**을 가진 웹 요청에서 상태를 유지하는 한가지 방법입니다.
그중 **쿠키**는 클라이언트에서 정보를 유지하는 방법입니다.

<br>

먼저 대략적인 플로우를 말해보면

<br>

1. 클라이언트는 서버측에 로그인 정보를 전달한다.
2. 로그인이 확인되면 서버측에게 필요한 **쿠키**를 전달한다. 이때 헤더에 **Set-Cookie**를 달고 값에 쿠키를 넣어준다.
3. 이후, 클라이언트의 서버측으로 요청에는 이 **쿠키**가 같이 전달된다.

<br>

이런 플로우를 가지게 됩니다. 위 플로우에 대한 내용은 아래 그림과 같습니다.

<br>

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Web/cp6/24쿠키.png" width="600" height="360" alt="">

<br>
<br>

## 쿠키와 사용할 수 있는 옵션들

---

쿠키는 부가조건을 추가하여 생성할 수 있습니다.

여기는 각각, **생명주기**, **도메인**, **접근경로**, **보안** 적인 옵션이 있습니다.

<br>
<br>

### 생명주기

---

생명주기 속성을 가진 것에는 **expires**와 **max-age**가 있습니다.

**expires**는 특정 기간까지 쿠키가 생존하는것을 나타내는 것이고, **max-age**는 현재시점 기준 특정한 시간동안 생존하는것을 말하게 됩니다.

<br>

**Set-Cookie: expires=Sat, 26-Dec-2020 04:39:21 GMT**

**Set-Cookie: max-age=3600**

<br>

**max-age**값을 0으로 지정하면 쿠키 삭제의 용도로 이용할 수 있습니다.

<br>
<br>

### 도메인

---

도메인은 쿠키가 특정 도메인에 속할때만 쿠키를 서빙 하는 옵션입니다.

예를들어 **example.com** 이라는 속성으로 domain을 명시하게 되면 **example.com** 도메인과 그 도메인이 가지는 서브도메인 까지
모두 포함해서 쿠키가 서빙 됩니다.

<br>
<br>

### 경로

---

**path("")** 이렇게 지정하게 되며, 보통은 루트 위치인 **/** 이용합니다. 예를들어 **/hello** 로 지정하면,
**/hello/1** 이런곳은 접근이 되지만, **/hi** 이런 위치에는 쿠키가 서빙되지 않습니디ㅏ.

<br>
<br>

### 보안

---

쿠키의 보안옵션은 3가지가 있습니다.

1. Secure
2. HttpOnly
3. SameSite

<br>

### Secure
  • 쿠키는 http, https를 구분하지 않고 전송

• Secure를 적용하면 https인 경우에만 전송

### HttpOnly

• XSS 공격 방지

• 자바스크립트에서 접근 불가(document.cookie)

• HTTP 전송에만 사용

### SameSite

• XSRF 공격 방지

• 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송

<br>

단, secure=false, samesite=None 과 같은 옵션들은 특정 브라우저에서 막히니 사용할때 잘 찾아보아야 한다.

<br>
<br>

## 세션이란?

---

웹에서 상태를 관리하는 다른 방법에는 **세션**이 있습니다.

**세션**이란 클라이언트 측이아닌 **서버**측에서 상태를 관리하는 방법입니다.

<br>

대략적인 플로우는 아래와 같습니다.

<br>

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Network/study/3주차/세션.png" width="600" height="360" alt="">

[사진 출처](https://dongsik93.github.io/til/2020/01/08/til-authorization(1)/)

<br>

1. 먼저 사용자가 서버측으로 로그인을 합니다.
2. 디비에서 사용자를 확인합니다
3. 확인이 완료되면 세션 디비에 새로운 로우를 생성합니다
4. 생성된 로우에서 sessionId를 사용자에게 돌려줍니다.
5. 이제 이러한 세션Id를 쿠키에 담아서 보낼수도 있고, 직접 보낼수도 있습니다.

<br>

이러한 과정을 거치게 됩니다.

<br>
<br>

## 쿠키와 세션의 차이와 장단점

---

쿠키는 상태유지를 **클라이언트** 측 리소스를 사용합니다. 하지만 세션은 **서버**에서 새로운 디비를 개설해 그곳에서 상태유지를 하게 됩니다.

이러한 차이점으로 인해 **클라이언트**리소스를 쓰는 쿠키가 상대적으로 서버의 리소스를 사용하지 않기 떄문에 속도적인 측면과 비용적인 측면에서 좋습니다.

반면에, 쿠키는 탈취당할 위험이 존재하지만 세션은 탈취당한다고 해도 중요한 정보는 **서버**에서 저장하고 있기 떄문에 보안적인 측면에서 안전합니다.

<br>
<br>

## 토큰이란?

---

토큰은 기존 인증 방식인 **쿠키**, **세션**에 대응되는 또 다른 상태유지 기법이다.

**토큰**이란 쉽게 생각해서 **티켓**이라고 생각하면 편하다.

극장이나 놀이공원을 갔을 때 미리 선별된 인원들은 특정한 누군가에게 **티켓**을 부여받고, 그 티켓에 적혀있는
대략적인 정보로 그 사람의 신원이나 접근 여부를 판단하여 입장여부를 판단하게 하는 것이다. 이것이 **토큰**의 역할이다.

기존 **세션 방식**은 서버의 리소스를 잡아먹어 오버 헤드가 매번 발생하는 문제가 있었고, **토큰**을 사용한다면 이를
개선할 수 있다.

토큰은 **jwt** 방식을 많이 사용하기 떄문에 **jwt**기준으로 설명하겠다.

<br>
<br>

## jwt 구조

---

**jwt** 토큰은 아래 사진처럼 크게 3부분으로 나누어진다.

<br>

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Network/study/3주차/jwt.png" width="600" height="500" alt="">

<br>

### 헤더

헤더는 시그니처에 사용될 해시 알고리즘과 토큰 타입에 대해 기술한다.

<br>

### 페이로더

페이로드는 실제 전달할 값이 담긴다. 이부분은 암호화되는것이 아니기 때문에 민감한 정보를 담아서는 안된다.

<br>

### 시그니처

시그니처는 헤더와 페이로더를 인코딩 후 헤더에 명시된 해시 알고리즘으로 해싱한 후, 개인키로 전자서명을 진행한다.
이러한 전자서명으로 토큰의 헤더나 페이로더가 위조되어도 서버는 위조여부를 판단할 능력을 가지게 된다.


