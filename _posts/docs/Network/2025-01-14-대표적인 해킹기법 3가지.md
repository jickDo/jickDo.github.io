---
title: 대표적인 웹 취약 해킹기법과 대응법
tags: 네트워크
article_header:
type: cover
---

오늘 설명하고자 하는 대표적인 해킹기법은 **XSS**, **CSRF**, **SQL Injection**입니다.

<br>
<br>

# XSS(Cross Site Script)

---

웹 클라이언트에 자바스크립트 와 같은 **스크립트**를 실행할 수 있는 코드를 삽입하여 다른 사용자들에게 공격자의 의도대로

공격을 하는 수법을 **XSS**라고 한다. 이는 특정 사용자가 특정 사이트를 신뢰하는 점을 이용하는 것입니다.

**XSS**는 공격자가 함정을 설치하고 기다린다고 하여 **수동적 공격**이라고 부르기도 합니다.

아래와 같은 예시로 공격할 수 있습니다.

<br>

1. 가짜 입력 폼 등에 의해 유저의 개인 정보를 도둑 맞는다
2. 스크립트에 의해 유저의 쿠키 값이 도둑맞거나 피해자가 의도치 않은 요청을 보내게 된다.
3. 가짜 문장이나 이미지를 표시한다.

<br>

## XSS의 대표적인 공격수단 3가지

---

**XSS**의 대표적인 공격방식은 3가지가 존재합니다.

### 1. Reflected XSS

### 2. Stored XSS

### 3. DOM XSS

차례대로 알아보겠습니다.

<br>
<br>

## 1. Reflected XSS

---

비지속적 기법이라고도 부르며, **악성 스크립트**가 웹 어플리케이션에서 피해자에게 반산될때 실행되는 해킹 기법입니다.

공격자가 조작된 **URI**링크를 배포하고 피해자가 이것을 눌렀을 때, 공격자가 원하는 사이트에 접근하거나, 세션 값을 탈취 하는 행위를 하게
됩니다.

<br>
<br>

## 2. Stored XSS

---

저장형 방식이라고도 하며, 공격자가 서버에 악의적인 스크립트를 담은 댓글이나 게시글을 저장시키며 진행됩니다.

다른 사용자가 악의적인 스크립트가 든 댓글이나, 게시글을 보게되면 스크립트가 실행되어, 쿠키나 토큰등을 탈취하는 방법을 말하게 됩니다.

<br>
<br>

## 3. DOM XSS

---

DOM 구조를 이용해서 요소들을 변경하는 동적인 행동을 할때 접근하는 JS코드에 악성 스크립트를 삽입하여 클라이언트 측 브라우저에서 악성 스크립트를 실행하는 기법입니다.

<br>
<br>

## XSS 방지법

---

1. 정규 표현식을 사용해 특수문자 입력 방지
2. 특수문자를 문자열로 치환하기
3. 쿠키에 HTTPOnly 속성 달기

<br>
<br>

# CSRF(Cross Site Request Forgeries)

---

**CSRF**란 사이트간 위조 요청이며 대표적인 웹 취약점중 하나입니다. 사용자가 의도하지 않은 요청이 실행됩니다.

즉, 일반사용자가 자신의 의도와는 상관없이 서버를 공격하는 행위입니다.

이는 특정 서버가 특정 사용자를 신뢰한다는 점을 이용하는 방식입니다.

<br>
<br>

## CSRF 전제조건

---

**CSRF**는 피해자의 인증수단을 이용하는 해킹 수법인 만큼 해킹을 위한 사전 조건이 필요합니다.

1. 사용자는 특정사이트에 로그인이 되어있어야 한다.
2. 특정 사이트는 쿠키기반 세션 관리를 진행한다.
3. 공격자는 서버를 공격하기 위한 요청 방법에 대해 미리 파악하고 있어야 한다.

위 세가지 과정이 만족되면 그 사이트는 **CSRF**공격 가능성이 존재하는 사이트가 된다.

<br>
<br>

## CSRF 공격 플로우

---

사용자는 **CSRF** 공격 가능성이 있는 서버에 접속하게 되면, 서버는 세션을 생성하고 쿠키에 세션ID를 담아서 사용자에게 전달할것입니다.

공격자는 악성 스크립트가 담긴 페이지를 누르게 유도합니다.

방법은 다양하지만 게시글에 악성 스크립트를 담을 수도있고, 인증메일에 넣을 수도 있고 다양한 방식으로 유도할수 있습니다.

그렇게 되면 사용자가 악성 페이지에 접속하게 되고, 그 페이지에는 공격을 하는 HTTP 요청 스크립트가 존재하고 거기에 더해 사용자의 세션키가 담긴 쿠키정보와 함깨 전송됩니다.

결국 사용자가 접속한 악성 페이지에서 악의적인 요청을 원래 보안 취약서버로 보내게 되고 이러한 공격 방식이 **CSRF**방식입니다.

<br>
<br>

## CSRF 방지법

---

1. referrer헤더와 host헤더의 비교
2. 쿠키, 세션 방식 사용안함(토큰사용고려)
3. 쿠키 설정값에 samesite를 true로 변경해서 퍼스트 파티 쿠키로 변경

<br>
<br>

# SQL Injection

---

**SQL Injection**은 이전에 보았던 **XSS**나 **CSRF**와는 조금 다른 특징이 있습니다.

이전 두개의 해킹기법은 **함정**을 설치하고 **피해자**를 기다리는 **수동적** 해킹 기법에 속하지만,

**SQL Injection**은 해커가 원하는 만틈 탐색 후 많은 조건을 수행하여 직접 뚫는 **능동적 해킹**기법에 속합니다.

**SQL Injection**은 이름 그대로 악의적인 **SQL** 문법을 삽입하고 기존 **SQL**구문을 파괴하는 방식으로 이용됩니다.

예를 들어, **SQL**의 한줄 주석은 **--** 으로 표현됩니다. 이를 활용해서 로그인 창에서 해커가 관리자의 계정을 알고있다면,

관리자의 계정뒤에 **Admin;--** 을 수행해서 추가적인 검증을 모두 무시하여 아이디만 존재해도 로그인이 되게 할 수 있습니다.

이러한 **SQL Injection**의 대표적인 방식은 4가지가 존재합니다.

<br>
<br>

## SQL Injection 4가지

---

### 1. 인라인 쿼리 인젝션

### 2. Union 기반 SQL 인젝션

### 3. 블라인드 SQL 인젝션

### 4. 에러 기반 SQL 인젝션

<br>

차례대로 설명하겠습니다.

<br>
<br>

## 1. 인라인 쿼리 인젝션

---

이름 그대로 사용자의 입력값을 검증하지 않아서 발생하는 문제입니다. 처음 예시로 들었던 해커가 어드민 계정을 알고 있고,
계정뒤에 주석처리 구문을 삽입했을 때 추가 검증없이 로그인 되는 방식이 **인라인 쿼리 인젝션**의 한종류 입니다.

좀더 악의적인 방식으로 풀어내면,

````sql
SELECT * FROM Users WHERE id = 'INPUT1' AND password = 'INPUT2'
````

이런 기본적인 로그인 쿼리가 있다고 가정합니다.

여기에 해커가 **INPUT1** 위치에 **'OR1=1 --** 을 집어넣게 되면 어떻게 될까요?

<br>

````sql
SELECT * FROM Users WHERE id = ''OR1=1 --' AND password = 'INPUT2'
````

위 구문처럼 강제로 id 조건 검사를 끝내버리고 **OR**연산자를 이용해 **1=1**을 통해 무조건 성공하는 케이스를 넣은뒤
그 후의 조건은 **--** 을 통해 주석화 해버립니다. 이렇게 되면 해커는 아이디를 몰라도 바로 접근이 됩니다.

<br>
<br>

## 2. Union 기반 SQL 인젝션

---

**SQL**에서 **UNION**키워드는 두 개의 쿼리문을 통합해서 조회하고 하나의 테이블로 보여주는 쿼리입니다.

정상적인 쿼리문에 **Injection**이 성공한다면 원하는 쿼리문을 조회하는데 이용될 수 있습니다.

이방식은 사전 조건이 필요합니다.

<br>

1. Union 하는 두 테이블의 컬럼 수가 같아야 한다.
2. 데이터 형이 같아야 한다.

이 두개의 조건이 맞춰지면 **Union Injection**을 사용할 수 있습니다.

<br>

아래 예시를 통해서 더 설명하겠습니다.

````sql
SELECT id, title, writer FROM board WHERE title LIKE '%검색어%';
````

이러한 게시판 검색기능이 있습니다.

해커는 검색어 부분에 아래와 같은 쿼리를 넣을 수 있습니다.

<br>

````sql
' UNION SELECT id, password, email FROM users--
````

<br>

이를 합치게 되면 아래와 같은 구문이 나오게 됩니다.

<br>

````sql
SELECT id, title, writer FROM board
WHERE title LIKE '%'
UNION
SELECT id, password, email FROM users--'
````

이런 방식으로 해커는 타입과 칼럼수를 맞춘다면 **UNION** 인젝션을 성공 시킬 수 있습니다.

<br>
<br>

## 3. 블라인드 SQL 인젝션

---

Blind SQL Injection은 데이터베이스로부터 특정한 값이나 데이터를 전달받지 않고,

단순히 참과 거짓의 정보만을 알 수 있을 때 사용합니다.

크게 두가지 방식으로 나누기도 합니다.

<br>

1. Boolean based SQL
2. Time based SQL

<br>

### 1. Boolean based SQL

---

````sql
SELECT * FROM users WHERE id='admin' AND password='INPUT'
````

<br>

이러한 원본 sql 코드가 있다고 가정합니다. 해커는 아래와 같이 입력하게 됩니다.

<br>

````sql
-- 첫 번째 글자 알아내기
admin' AND ASCII(SUBSTRING((SELECT password FROM users WHERE id='admin'),1,1))>97--  // a보다 큰가?
admin' AND ASCII(SUBSTRING((SELECT password FROM users WHERE id='admin'),1,1))>100-- // d보다 큰가?
admin' AND ASCII(SUBSTRING((SELECT password FROM users WHERE id='admin'),1,1))=101--  // e인가?

-- 두 번째 글자 알아내기
admin' AND ASCII(SUBSTRING((SELECT password FROM users WHERE id='admin'),2,1))>97--
````

<br>

이렇게 입력하게 되면 해커는 곧 비밀번호를 알아낼 수 있을것입니다. 비슷한 방식으로 존재여부에 대한 질의로 많은것을 알 수 있습니다.

<br>
<br>

### 2. Time based SQL

---

**Time based SQL Injection**은 데이터베이스의 응답 시간을 이용해 데이터를 추출하는 공격 기법입니다.

<br>

````sql
' AND IF((SELECT COUNT(*) FROM users WHERE id='admin')=1, SLEEP(3), 0)--
````

위 코드처럼 id가 admin이 존재한다면 지연시간이 3초 이상걸리기 떄문에 true/false방식으로 지연시간을 이용하는 방식입니다.

<br>
<br>

## 4. 에러 기반 SQL 인젝션

---

마지막은 에러기반 인젝션입니다.

쉽게 설명이 가능하기 때문에 예시 코드는 작성하지 않겠습니다.

**SQL**에서 문법 구문이 틀렸을 경우 왜 틀렸는지에 대한 예외를 반환해줍니다.

**공격자**는 이 구문을 보고 정보를 탐색해나가는 과정을 거치고 이를 해킹에 사용하는 것입니다.

<br>
<br>


## SQL Injection 대응법

---
1. SQL 예외 메시지 숨기기

2. input값 검증하기

<br>

이는 클라이언트 사이드와 서버 사이드 모두 수행하여야 합니다. 클라이언트 사이드는 잘못된 값에 대한 검증용으로,

서버사이드는 직접적인 공격자의 호출에 대응하기 위해 검증을 수행해야 합니다.


<br>
<br>
<br>

[참고한 레퍼런스1](https://bziwnsizd.tistory.com/89)
[참고한 레퍼런스2](https://velog.io/@jeongbeom4693/Security-SQL-Injection)
