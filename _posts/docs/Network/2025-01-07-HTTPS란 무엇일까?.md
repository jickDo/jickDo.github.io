---
title: HTTPS란?
tags: 네트워크
article_header:
type: cover
---

# HTTP 의 약점

---

**HTTPS**를 사용하는 이유는 **HTTP**의 보안적인 약점 때문입니다.

<br>

### 1. 평문 통신의 도청 가능성

### 2. 통신 상대를 확인하지 않기 때문에 위조 가능

### 3. 완전성을 증명할 수 없기 때문에 변조가능

<br>

이러한 문제로 인해서 **HTTPS**를 사용하게 됩니다.

<br>
<br>

## 1. 평문이기 때문에 도청이 가능하다.

---

여기서 **평문**이란 **암호화 되지 않은 메시지**를 의미하며, HTTP 자체에 암호화 기능이 없기 때문에 모든 요청과 응답은
**평문**으로 이루어 지게 됩니다.

<br>
<br>

### TCP/IP 는 도청 가능한 네트워크

---

TCP/IP의 구조의 통신 내용은 전부 통신 경로의 도중에 엿볼 수 있습니다. 인터넷은 전 세계를 경우하는 네트워크이며,
서버 클라이언트 통신간 경로에서 있는 일을 소유할 수 없기 때문에 누구나 엿볼 수 있습니다.

이러한 방식으로, 통신중 암호화를 하지 않은 메시지는 누구나 확인할 수 있습니다.

<br>
<br>

### 암호화로 도청을 피할 수 있다.

---

도청을 피할 수 있는 암호화 방식은 **2개**가 존재합니다.

<br>
<br>

### 1. 통신 암호화

### 2. 콘텐츠 암호화

<br>
<br>

### 통신 암호화

---

통신 암호화는 **SSL**, **TLS** 이라는 다른 프로토콜을 조합해서 HTTP의 통신 내용을 암호화 할 수 있습니다.

**SSL**등을 이용해 안전한 통신로를 확립하고 나서 그 통신로를 사용해 **HTTP**통신을 합니다.

<br>
<br>

### 콘텐츠 암호화

---

다른 방식은 콘텐츠 내용 자체를 암호화 하는 방식입니다.
**HTTP**에 암호화 기능이 없기 떄문에, **HTTP**가 운반하는 메시지 자체를 암호화 해버리는 것입니다.
이러한 방식은 클라이언트가 복호화를 수행하여야 한다는 단점이 있습니다.

<br>
<br>

## 2. 통신 상대를 확인하지 않기 때문에 위조 가능

---

**HTTP**를 사용해서 요청, 응답을 하게 되면 통신 상대를 확인하기 어렵습니다. 요청을 보낸 서버가 정말 **URI**에 지정된
호스트인지,
응답을 받은 클라이언트가 정말로 목적지의 클라이언트인지 말입니다.

<br>
<br>

### 누구나 요청을 할 수 있다.

---

이러한 문제점 때문에 누구나 **HTTP** 통신을 요청 할 수 있습니다. **HTTP**특성상 요청이 온다면 무조건 반환을 하기 때문에
상대가 누구인지 확인하지 않고 반환을 진행합니다.

이러한 문제는 **요청 주소지**, **응답 주소지** 의 상대가 위조될 수 있고, 누구나 요청할 수 있는 문제는 **브루트 포스**형식의
해킹시도로 이어지기도 합니다.

<br>
<br>

### 클라이언트는 서버의 위장 여부를 확인 가능하다

---

클라이언트가 요청하는 서버가 위장 한 서버인지 확인하는 여부는 **CA**라고 불리는 제3자 기관에 의해 가능합니다.

**CA**는 해당 서버에 증명서를 만들어주고, 클라이언트로 하여금 해당 증명서로 믿을 수 있는 서버인지 판가름하게 합니다.

<br>
<br>

## 3. 완전성을 증명할 수 없기 때문에 변조가능

---

여기서 말하는 **완전성**은 **정보의 정확성**을 말하게 됩니다. 요청을 보내고 받을 때 값이 **정확한**값인지 확인이 불가능 할 수
있습니다.

<br>
<br>

### 수신한 내용이 다를수 있다.

---

**HTTP**에서 요청, 응답의 값이 중간지점에서 변조되어도 그것을 받은 곳에서는 위조된 정보인지, 맞는 정보인지 판가름 할 수 없습니다.
보낼때의 값이랑 도착하고 값이 달라진다는 의미입니다.

이러한 공격방식은 **중간자 공격(Man-in-the-Middle)이라고 부릅니다.

물론, 이를 **MD5**나 **SHA-1** 등의 해시 값을 통해 확인할 수 있지만, 클라이언트 측에서 이를 재검사하는 로직과, 이러한
해시값도
조정되어 오게 되면 클라이언트가 알 수 없는 단점이 존재합니다.

확실한 방지를 위해서는 **HTTPS**를 사용해야 합니다.

<br>
<br>

# HTTPS란?

---

위에서 말한 것처럼 **HTTP**자체의 보안 문제로 인해 **HTTPS**를 사용하게 됩니다.

**HTTPS란** 이전의 **HTTP**에 암호화나 인증 등의 구조를 더한것을 **HTTPS**라고 부릅니다.

<br>
<br>

## HTTPS 의 구조

---

<br>

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Network/study/2주차/HTTPS.png" width="600" height="360" alt="">

<br>
<br>

위 그림처럼 기존 **HTTP**에서 **HTTP 통신** 을 하는 소켓 부분을 **SSL**, **TLS**이라는 프로토콜로 대체하는 형태입니다.

**HTTP**의 경우라면 바로 **TCP**와 소통을 하게 되지만, **SSL**을 사용하게 되면 **SSL**이 **TCP**와 소통하게 됩니다.

이러한 과정을 거치면서 **암호화**, **증명서** 등의 기능을 이용할 수 있게 됩니다.

<br>
<br>

# 암호화 방식

---

**HTTPS**의 암호화 방식을 설명하기 위해 기존에 존재하던 **암호화 방식**을 정리하겠습니다.

대표적인 암호화 방식에는

<br>

### 1. 대칭키 암호화 방식(비공개키)
### 2. 비대칭키 암호화 방식(공개키)

<br>

두가지 방식이 있습니다.

<br>
<br>

## 1. 대칭키 암호화 방식(비공개키)

---

대칭키 암호화 방식은 비공개키 암호화 방식이라고도 부릅니다.

**대칭키**는 말그대로 키가 대칭된다. 즉, **암호화**, **복호화** 과정에서 사용하는 키가 동일 하다는 것입니다.
**동일한 키**를 사용하기 때문에 이 **키**는 노출이 되면 안되며, 그렇기 때문에 **비공개 키**라는 이름으로 불리기도 합니다.

<br>
<br>

### 대칭키 방식의 문제점

---

대칭키 방식은 이후에 나올 **비대칭 키** 방식보다 빠르고 간편하다는 장점이 있습니다. **마스터 키**하나로 모든것을 해결하기 때문입니다.

하지만, 여기서 한가지 큰 문제점이 있는데 서버와 클라이언트간 **암호**, **복호**과정중 한번은 **키**를 교환하는 과정이 필요하게 됩니다.

좀전에 **마스터 키**라는 비유를 들었는데 이 **마스터 키** 교환 과정중 키가 탈취당하면 탈취한 사람은 암호화된 내용을 언제든 **복호화**할 수 있다는 문제점이 있습니다.

<br>
<br>

## 2. 비대칭키 암호화 방식(공개키)

---

이러한 대칭키의 문제점을 **비대칭키 암호화 방식** 이 해결할 수 있습니다.

이름 그대로 키가 대칭되지 않다는 말은 **암호화**, **복호화**키가 따로 존재한다는 것입니다.

**암호화** 와 **복호화**중 숨겨야 할 부분에 대해서 **Private Key**로 지정하고 반대측을 **Public Key**로써

모두가 볼 수 있게 만듭니다.

**암호화** 와 **복호화**중 어디에서 **Private Key**를 사용하는지는 바로 아래에서 다루겠습니다.

<br>
<br>

### 복호화에서 개인키 사용

---

복호화에서 **개인키**를 사용하게 되면 **평문 암호화**의 기능을 가지게 됩니다.

**Public Key**를 이용해서 암호화를 진행하고 암호화된 평문을 전달하게 되면, 해커가 **Private Key**를 가지고 있지
않다면 암호화된 평문을 복호화 할 수 없을 것입니다.

이러한 방식은 누구나 **암호화**를 진행할 수 있게 하고, 그것을 **복호화**하는 곳에서만 **Private Key**를 이용하면 되기 때문에

키 탈취 문제를 걱정하지 않아도 된다는 점이 존재합니다.

<br>
<br>

### 암호화에서 개인키 사용

---

암호화에서 **개인키**를 사용하게 되면 조금 다른 목적으로 사용할 수 있습니다.

믿을 수 있는 기관을 **CA(Certifacate Authority)** 라고 부릅니다. 이러한 **CA**가 **개인키**를 이용해서

믿을 수 있다는 정보를 **인증서**로 만들게 됩니다. 그러면 이러한 **CA**의 **공용키**를 이용해서 누구나 요청에 대한 검증을

할 수 있다는 기능을 할 수 있습니다.

<br>
<br>

## 전자 서명

---

조금전 암호화에서 개인키 사용을 **인증서**의 목적으로 사용가능 하다고 했습니다.

조금더 자세하게 **CA**가 어떻게 서버의 **공개키**를 증명하는지 설명하겠습니다.

대략적인 플로우는 아래와 같습니다.

<br>

> 1. 서버가 자신의 공개키를 **CA**에게 전송
>
> 2. **CA**는 자신의 비밀키로 서버의 공개키를 서명한후 증명서에 서버의 공개키를 담아서 재발송
>
> 3. 서버는 클라이언트에게 증명서를 발송
>
> 4. 클라이언트는 사전에 브라우저에 존재하는 **CA**의 공개키로 조작되지 않은 서버의 공개키인지 검사

이 과정을 통해서 클라이언트의 **공개키**를 신뢰할 수 있는 **CA**를 통해서 검증하는 것이 전자 서명입니다.


<br>
<br>

## HTTPS의 하이브리드 암호 방식

---

조금 돌아오긴 했지만 본래 목적인 **HTTPS**에서 암호화 하는 방식을 설명하겠습니다.

**비대칭 키 방식**은 **대칭 키**방식보다 키 교환및 탈취의 우려가 적어서 안전하다는 장점이 있습니다.

하지만, **비대칭 키 방식**은 느리다는 단점이 존재하고 이런 느린 플로우를 매번 수행하게 되면 비효율적입니다.

그렇기 때문에 **HTTPS**에서 는 두가지 방식 모두 사용하는 암호 시스템을 사용합니다.

방식은 아래와 같습니다.

> 1. 안정성이 높은 비대칭키 방식을 이용해서 대칭키를 암호화해서 키 교환을 진행합니다.
>
> 2. 안전하게 대칭키를 전달받았으면 이후부터 속도가 빠른 대칭키를 이용해서 암호화 과정을 진행합니다.

<br>
<br>



















