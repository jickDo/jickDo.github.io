---
title: TCP와 UDP
tags: 네트워크
article_header:
type: cover
---

<br>

**TCP**와 **UDP**는 트랜스포트 계층에 속한 프로토콜입니다. 각각 신뢰성과 즉시성을 중요시 하는 프로토콜이며

상황에 맞게 이용합니다.

이들은 모두 **트론스포트 계층**의 역할인 **포트 번호**를 이용한 어플리케이션의 식별을 담당 하게 됩니다.

<br>
<br>

# UDP란 무엇인가?

---

**UDP(User Datagram Protocol)** 은 **트랜스 포트 계층**에서 **즉시성**을 중요시하는 어플리케이션에 사용합니다.

주로 **음성통신**이나 **이름 결정**과정에서 사용합니다.

기본적으로 즉시성을 위해 커넥션 리스 형태로 이루어지기 때문에 사전에 요청없이 **UDP 커넥션**을 만들고, 어플리케이션 데이터를 송신합니다.

<br>
<br>

## UDP 패킷

---

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Network/study/4주차/udp-packet.png" width="500" height="150" alt="">

<br>
<br>

**UDP**패킷은 사용목적에 맞게 패킷의 내용이 많이 없습니다. 그렇게 해야지 송 수신간의 빠른 실시간성을 보장할 수 있기 때문입니다.

**UDP**는 헤더에 포함된 **데이터그램 길이** 그리고 **체크섬**을 이용해서 데이터 손상여부를 체크합니다. 이러한 체크에 성공하면 그때 데이터를 받아들입니다.

**데이터그램 길이** 이란, **UDP**의 **헤더**와 **페이로더**의 전체 길이를 나타내는 필드입니다.

**체크섬이란** **UDP** 세거먼트의 오류 검출을 위해 사용하는 방법입니다. 송신할 세그먼트를 16비트로 나누고,

이를 모두 더한 다음 1의 보수연산을 통해 만듭니다. 이와 같은 방법으로 수신자는 같은 과정을 진행하며 전달받은 체크섬과 만든 체크섬을 비교합니다.

<br>
<br>

# TCP란 무엇일까?

---

**TCP**는 메일이나 파일, 혹은 **신뢰성**이 필요한 모든 에플리케이션에서 사용됩니다. **UDP**와는 다르게, **신뢰성**이 강조된 프로토콜입니다.

**TCP**는 데이터를 송신하기 전에 **TCP 커넥션**을 만들고 통신을 시작합니다. 이러한 커넥션은 보내고 받는 곳에따라 다른 파이프를 이용합니다.

보내는 측은 송신 파이프, 받는 측은 수신파이프 를 이용합니다.

<br>
<br>

## TCP 패킷

---

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Network/study/4주차/tcp-packet.png" width="500" height="150" alt="">

<br>
<br>

### 시퀀스 번호

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Network/study/4주차/시퀀스번호.png" width="600" height="250" alt="">


**시퀀스 번호**란 **TCP** 전송과정에서 신뢰성을 보장하기 위해서 세그먼트에 순서를 부여한 것입니다.

<br>
<br>

### 확인 응답 번호

확인 응답 번호는 **ACK**라는 형태로 부르게 됩니다. 수신측이 전달한 **시퀀스 번호**를 보고 그 다음 데이터는 **'여기부터 주세요'** 를 상대에게 전달하기

위해 사용하는 필드입니다. **시퀀스**가 12번으로 요청이 왔으면 순차적인 **시퀀스**의 특성에 따라 **ACK**는 시퀀스+1 인 13을 요청하는 방식입니다.

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Network/study/4주차/확인응답번호.png" width="700" height="500" alt="">

<br>
<br>

## TCP 에서 상태전이

---

**TCP 상태전이**란 신뢰성을 확보하는 플로우를 3가지 단계로 나눈것을 말합니다. 차례대로 **접속 시작 단계**, **접속 확립 단계**, **접속 종료 단계** 3가지로 나뉜니다.

<br>
<br>

## 접속 시작 단계

---

**접속 시작 단계**는 다른 말로 **3way handshake**라고 표현합니다. 이전에 **TCP**는 **UDP**와는 다르게 통신 전 **연결로**를 만든다고 하였는데,

이 단계가 **TCP 연결로**를 만드는 과정입니다.

앞으로 이러한 **연결로**를 **커넥션**이라고 표현합니다.

**3way handshake**에서 **커넥션**을 만들어 가는측은 **액티브 오픈**, 반대편은 **패시브 오픈**이라고 부릅니다.

아래 사진을 중심으로 설명하겠습니다.

<br>
<br>

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Network/study/4주차/3way-handshake.png" width="600" height="650" alt="">

<br>

1. **3way handshake**를 진행하기전 클라이언트는 **CLOSED**, 서버는 **LISTEN** 상태입니다.

2. 클라이언트는 **SYN**플래그에 1, 시퀀스 번호에 무작위값을 설정한 **SYN 패킷**을 송신하고, 오픈처리에 들어갑니다.

3. 이러한 **SYN 패킷**을 받은 서버는 **패시브 오픈**처리에 들어갑니다. **SYN**, **ACK** 모두 1로 설정한 패킷을 클라이언트로 송신합니다. 이때 패킷 시퀀스에 무작위 y를
작성하고 조금전에 받은 시퀀스에 1을 더해 확인 응답에 담습니다.

4. 이렇게 서버가 보낸 **패킷**을 받은 클라이언트는 **ACK** 1을 다시 보내고 **ESTANBLISHED**로 상태를 변경합니다. 여기까지 진행되면 **커넥션 수립**과정을 완료입니다.


<br>
<br>

## 접속 확립 단계

---

접속 확립 단계는 실제 어플리케이션 데이터를 교환하는 과정입니다. **TCP**는 애플리케이션 데이터 전송의 신뢰성 확보를 위해 **흐름 제어**, **혼잡 제어**, **재전송 제어** 라는 3가지
제어 과정을 사용합니다.

<br>
<br>

### 흐름제어

**흐름 제어**는 수신 측 단말이 수행하는 흐름양 조정입니다.

**윈도우 크키**라는 개념이 나오는데, **TCP** 과정에서 수신 측 단말이 받을 수 있는 크기를 명시한 필드입니다.

수신측에서는 **윈도우**크기 이상의 값을 보내지 않습니다.

자세한 예시는 아래와 같습니다.

<br>

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Network/study/4주차/흐름제어.png" width="600" height="650" alt="">

<br>
<br>

### 혼잡 제어

**혼잡 제어**는 송신 측 단말이 수행하는 흐름양 조정입니다. **TCP**는 대량의 송신 패킷에 의해 네트워크가 혼잡해지지 않도록, **혼잡 제어 알고리즘** 을 이용해,

패킷 송신 수를 제어합니다. 이 패킷 송신 수를 **혼잡 윈도우**라 부릅니다. 혼잡 제어 알고리즘은 혼잡하면 혼잡 윈도우를 줄이고 혼잡하지 않으면 윈도우를 늘립니다.

<br>

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Network/study/4주차/혼잡제어.png" width="400" height="300" alt="">

<br>
<br>

### 재전송 제어

---

재전송 제어는 패킷 유실이 발생했을 때 수행하는 패킷 재전송 기능입니다. **TCP**의 **신뢰성**을 보장하는 주요한 기법입니다.

**재전송 제어**는 두가지 기법이 존재합니다.

1. 수신측이 계기가 되는 **중복 ACK**
2. 송신측이 계기가 되는 **재전송 타임아웃**

<br>

### 중복 ACK

---

수신측이 데이터를 받을 때 전달받은 시퀀스 번호가 듬성 거리면 즉 연속적이지 않은 시퀀스 번호를 받게 되면 받지 못한 데이터에 대한 재전송을 요구합니다.

그 방식은 3번 데이터를 못받았으면 2번데이터에 대한 **ACK**를 보내서 다음 데이터를 보내라고 하는 방식입니다.

**송신**측이 이러한 중복 **ACK**를 계속 받게 되면 그떄서야 유실된 데이터를 보내게 됩니다.

<br>

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Network/study/4주차/빠른재전송.png" width="600" height="650" alt="">

<br>
<br>

### 재전송 타임아웃

---

송신측이 값을 보내고 **ACK**를 기다리기 까지의 시간을 **재전송 타이머**로 유지합니다.

보내는 데이터의 갯수가 적은 경우 **중복 ACK**가 발생하지 않을 수도 있기 때문에, 이런 경우에 재전송 타임아웃으로 검출하게 됩니다.

<br>

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Network/study/4주차/재전송타임아웃.png" width="600" height="650" alt="">

<br>
<br>

## 접속 종료 단계

---

**커넥션 종료 단계**에서는 **3 way handshake**가 아닌 **4 way handshake**를 사용하게 됩니다.

이렇게 종료 단계에서 더 신중한 과정을 거치는 이유는 종료 처리에 실패하면 불필요한 리소스가 단말에 남아 있기 때문입니다.

**3 way handsahke**는 시작을 클라이언트 측에서 시작하게 되지만, 종료는 양측다 시작을 수행할 수 있습니다.

그렇기 떄문에 종료하련느 측을 **액티브 클로즈**, 받는 측을 **패시브 클로즈**라고 합니다.

자세한 내용은 사진을 통해서 설명을 이어가겠습니다.

<br>
<br>

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Network/study/4주차/4way-handshake.png" width="600" height="650" alt="">

<br>
<br>

1. 보내는 측 여기서는 클라이언트로 고정하고, 클라이언트는 **FIN/ACK** 값을 1로 만들어 서버측으로 패킷을 송신합니다.

2. 이를 받은 서버는 **패시브 클로즈** 처리를 시작합니다. 클라이언트 측으로 받은 요청에 대한 **ACK**처리를 합니다.

3. 서버는 이번에 자신의 어플리케이션에서 클로즈 요청이 오게 되면 **FIN/ACK** 패킷을 송신합니다.

4. 클라이언트는 패킷을 받고 **TIME-WAIT**라는 상태로 전환합니다. 이상태는 서버가 마지막으로 **ACK**를 못받을 경우에 대비한 상태입니다.

5. **ACK**를 받은 서버는 **CLOSED**상태로 전환하고 커넥션을 삭제합니다. 이와 함깨 모든 자원을 해제 합니다.

6. 클라이언트 측도 같은 과정을 반복합니다.



<br>
<br>
<br>
<br>


참고한 레퍼런스: [그림으로 공부하는 TCP/IP 구조]









