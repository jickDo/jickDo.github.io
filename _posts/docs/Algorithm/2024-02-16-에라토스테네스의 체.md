---
title: 에라토스테네스의 체란?
tags: 알고리즘
article_header:
type: cover
---
# 에라토스테네스의 체란?

---

에라토스테네스의 체는 소수를 판별하기 위해 사용되는 알고리즘의 일종이다. 소수란 1을 제외한 약수가 1과 자기자신만이 존재하는 수이다. 그러한 소수를 판별하는
문제는 알고리즘에서 흔하게 볼 수 있다. 하지만 많은 소수 문제들은 범위를 상당히 크게 주어 시간복잡도 면에서 걸리게 된다. 그럴때 선택할 수 있는 선택지로
에라토스테네스의 체가 있다.

<br><br>

## 에라토스테네스 이해하기

---

에라토스테네스를 이해하기 위해서는 에라토스 테네스를 그림으로 보면 이해하기 쉽다.

<br>

<img src="https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif">

<br>

[위키피디아 출처](https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4)

사진에서 볼 수 있듯이, 에라토스 테네스를 하나의 말로 요약하자면,

> "주어진 길이의 숫자들중에서 소수가 아닌경우를 소거법하면 결국 남는것은 소수이다".

이를 조금 풀어서 과정으로 생각하게 되면,

> 1. 1은 소수의 정의에서 언급되듯이 소수가 아니기떄문에 제외시킨다.

> 2. 2는 소수이다. 소수 배열에 추가한다.
> 3. 2의 배수는 모두 소수가 아니다.

> 4. 3은 소수이다. 소수 배열에 추가한다.
> 5. 3의 배수는 모두 소수가 아니다.

> 6. **4와 그의 배수는 모두 2의 배수에서 확인되는 경우이므로 4는 무시한다.**

> 7. 5은 소수이다. 소수 배열에 추가한다.
> 8. 5의 배수는 모두 소수가 아니다.

> 9. **6와 그의 배수는 모두 2의 배수에서 확인되는 경우이므로 6은 무시한다.**

> 10. 7은 소수이다. 소수 배열에 추가한다.
> 11. 7의 배수는 모두 소수가 아니다.

<br>

에라토스테네스의 체는 위와같은 로직을 가지게 된다. 여기서 생각해보아야 할점은 어디까지 판별을 해야하는 가와,
위의 과정을 전부 코드로 표현하면 상당히 지저분한 코드가 된다는 점이다.
하지만, 걱정할 필요가 없다.

**에라토스테네스의 체를 코드로 표현하게되면 고려할 부분이 상당히 제거된다는 특징이있다.**

<br><br>

## 에라토스테네스의 체 코드로 표현하기

---

````java
class Solution {
    public int solution(int n) {
        boolean[] decimal = new boolean[n+1];
        int result = 0;
        decimal[0] = decimal[1] = true;

        for(int i = 2; i*i <= n; i++){
            if(decimal[i] == true){
                continue;
            }
            for(int j = i * i; j <= n; j += i){
                decimal[j] = true;
            }
        }

        for(int i=1; i<=n; i++){
            if(decimal[i] == false){
                result++;
            }
        }
        return result;
    }
}
````

### 되짚어보기

위 코드는 프로그래머스 소수 찾기 문제를 해결하며  에라토스테네스의 체를 사용한 것이다. 우선 에라토스테네스의 체의 기본 원리를 다시 떠올리고 가면, 특정 범위까지의
수중에서 소수를 판별하고 싶다면, 아닌경우를 제외하다보면 최종적으로 남는 경우가 소수가 되는 알고리즘이다.

---

### 마지막수의 제곱근까지 판별

이를 코드로 표현하게 되면 마지막수의 제곱근까지 반복문으로 확인하면 된다.

이유는 특정 수의 제곱근까지 확인하게 되면 결국 그 이후부터는 같은 패턴을 반복하기 떄문이다.

이것이 코드상에서 7라인에 있는 범위를 **i*i <= n**로 만든 이유이다.

---

### 배열의 시작은 비워두기!

또한 인덱스의 시작은 0이고 수의 소수 판별의 시작은 1이기 때문에 첫번째 배열은 비우고 계산하게 된다.

그리고 1또한 소수의 정의에서 벗어나기 떄문에 0번인덱스와 1번인덱스의 처리는 먼저하고 간다.

---

### 이전 인덱스에서 판별한 i값은 조건문으로 건너뛰자

4나 6같은 수는 2의 배수에서 걸러지고 추후에 4와 6의 모든 배수는 2의배수안에 들어가기 떄문에 조건문을 통해서 순환의 경우를 줄이자

---

### 순환에서 만나는 경우 소수가 아님을 처리하자

````java
if(decimal[i] == false){
    result++;
}
````

위 경우처럼 i의 순환에서 만나는 경우는 소수가 아님을 의미하기 때문에 소수가 아님을 처리하자


## 결론

---

1. 소수 판별알고리즘으로 에라토스테네스의 체가 있다.
2. 입력값이 큰경우 우선적으로 에라토스테네스의 체를 고려하자
3. 초기처리를 잘하자
