---
title: 객체지향의 4가지 특징 - 다형성
tags: OOP
article_header:
type: cover
---
# 객체지향의 4가지 특징 - 다형성

---

코틀린을 메인언어로 사용하다가 최근에 자바를 공부중이였는데 비어있는 개념을 발견하여 이참에 객체지향에 대해 더욱 단단하게 기초를 쌓고자
객체지향 4가지 특징을 정리하고자 한다.

<br><br>

## 다형성(Polymorphism)

---

다형성은 객체지향의 꽃이라고 생각한다.
다형성(Polymorphism)은 이름에서 드러나듯이 다양한 형태, 여러 형태를 뜻한다. 이를 프로그래밍 영역으로 가져오게 되면 **한 객체가 여러가지 형태로 변할수 있는 능력**
이라고 할 수 있다. 즉 한 객체를 다른 객체로 필요에 따라 변화시켜 사용할 수 있게 해주는 특징이다.

다형성에는 두가지 중요한 개념이 있다.
첫번째는, **다형적 참조** 그리고 두번째는 **메서드 오버라이딩**이다. 각각 아래에서 살펴 보겠다.

<br><br>

## 다형적 참조

---

다형적 참조는 **부모객체는 자식을 담을수 있다**로 요약이 가능하다. 이제 이에 대한 설명은 아래의 코드를 통해서 하겠다.

````java
public class School {
    public void play(){
        System.out.println("자식에게 노는법을 알려줍니다");
    }
    public void study(){
        System.out.println("학생의 본분은 공부!");
    }
}
````
먼저 부모 클래스로 사용할 학교를 선언하고

````java
public class ElementarySchool extends School{

    @Override
    public void play(){
        System.out.println("초등학생은 열심히 놀아야 합니다!");
    }
}
````

이를 상속받는 초등학교라는 자식을 만든다.

>자식에게 노는법을 알려줍니다
>초등학생은 열심히 놀아야 합니다!

이것을 메인에서 출력하면 자식은 부모의 메서드를 물려받지만 오버라이딩을 통해서 자신만의 기능을 수행한다.

상속관계에 대한 짤막한 이해를 했으니 이제 진짜로 다형적 참조가 무엇인지 확인하겠다.

````java
School school = new ElementarySchool();
school.play();
school.study();
````

위 코드와 같이 부모 객체의 변수(School)가 자식의 인스턴스를 참조하고 있다. 즉 부모의 변수가 자식을 품고있는 상황이다.
위 코드의 출력은 신기하게 작동한다.

>초등학생은 열심히 놀아야 합니다!
>
>학생의 본분은 공부!

위의 출력은 자식 객체 메서드에 대한 출력이고 아래 출력은 부모 객체에 대한 출력이다. 분명 같은 객체 변수에 .(dot)을 찍어 출력을 하였는데
왜 다른 클래스 메서드를 참조하는 일이 일어날까?

정답은 **다형적 참조**이다. 아래 사진을 참고하자


위 부모 객체는 자식 인스턴스를 담고있고 자식 인스턴스는 생성시 상속받은 부모 객체를 같이 생성하게 된다. 즉 힙영역 메모리 주소값에 부모와 자식이 같이 생성되어 있는것이다.
위와 같은 구조때문에 부모 객체변수는 자식 메서드와 부모 메서드를 둘다 호출해서 사용해도 가능한것이다.

결론적으로 부모는 자식을 담을 수 있고, 자식은 생성시 부모 객체를 같이 생성하기 때문에 이러한 이유들 때문에 하나의 객체가 상속관계 하에서 다양한 형태로 변할 수 있다.
이것이 다형성의 시작이다.

<br>

### 하지만 여기에도 한가지 문제가 있는데,

````java
public void elementStudentHabbit(){
    System.out.println("초등학생만의 습관이 있다!");
}
````
자식에 위와같은 자식만의 기능을 추가하고 이를 부모에서 사용하게 되면 컴파일 에러가 발생한다. 이유는 school 변수는 School타입의 부모 타입이다. 따라서
school입장에서는 본인의 인스턴스부터 찾는다. 하지만 **elementStudentHabbit**메서드는 자식만의 메서드를 지정한것이다. 따라서 부모 인스턴스에서 자식인스턴스로
참조가 일어나야 하는 상황인데 **문제가 이곳에서 발생한다.**

자식은 코드상에서 부모를 알고있지만, 부모는 자식을 모른다. 따라서 부모는 자식을 향한 참조를 할 수가 없다. 이를 해결할 방법으로는 **캐스팅**이 있다.
**캐스팅**이랑 특정한 형태를 다른 형태로 변환시키는 기능이다. School school의 변수 생성을 자식 타입의 변수로 바꿀수 있다면 자식은 부모도 참조 가능하고 당연히
본인도 참조가능 하기 때문에 이를 해결할 수 있을것이다.

<br>

### 다형적인 캐스팅하기

````java
ElementarySchool elementarySchool = (ElementarySchool) school;
````

위와같이 기존 School school로 생성한 변수를 강제로 ElementarySchool로 형변환을 할 수가있다.


이를 **다운 캐스팅**이라고 하며 부모타입 객체변수를 자식타입 객체 변수로 강제로 캐스팅을 한 경우이다. 이렇게 캐스팅을 하게 되면 자식타입에서 부모타입으로 참조가 가능하기 때문에
연관된 모든 메서드의 사용이 가능해진다.

또한 업케스팅도 있지만 여기에서 다루지 않을것이다. 이유는 다운케스팅은 위험성이 있고 업케스팅은 안전하기 때문에 다운케스팅의 주의점만 살펴볼것이다.

<br>

### 다운 케스팅시 주의점

````java
School school = new School()
ElementarySchool elementarySchool = (ElementarySchool) school;
````

위 코드가 다운케스팅의 주의점을 잘 나타낸 코드라고 할 수 있다. 좀 전에 자식 객체는 생성될때 연관된 부모를 같이 생성한다고 했다. 하지만 첫 생성을 부모객체로하고
자식객체로 강제 다운 캐스팅을 하게되면 힙 메모리 영역에 부모 객체만 생성되어 있기 때문에 참조할 자식 객체가 없어서 캐스팅 에러가 발생하니 주의해야 한다.

### 결론적으로 다형적참조는 부모타입이 자식타입을 담을 수 있다는 것이다.

<br><br>

## 메서드 오버라이딩

---

다형성에서 두번째로 중요한 메서드 오버라이딩이다. 메서드 오버라이딩에서 가장 중요한 점은 **오버라이딩 된 메서드는 우선권**을 가진다는 것이다.
이 말은 부모 객체에서 나온 기능을 자식이 오버라이딩 후 호출했을때 오버라이딩 된 메서드가 사용된다.

이부분이 중요한 이유는 좀전에 부모 객체는 자식객체로의 참조가 불가능 하다고 했다.

비슷하지만 한가지 예외로 부모가 호출한 메서드가 자식이 오버라이딩 한 메서드라면 부모에서
자식으로 메서드 참조가 일어나 오버라이딩 된 메서드를 호출한다. 이것이 이후에 다형성에서 큰 기여를 하게 된다.

<br><br>

## 다형성 활용 예시

---

다형성 활용 예시까지는 작성할 생각이 없었는데, 다형성이 객체지향의 꽃이라고 생각하기도 하고 중요한 내용이라 활용까지 한번 해보고자 한다.

````java
 @Override
    public void play(){
        System.out.println("초등학생은 열심히 놀아야 합니다!");
}

@Override
    public void play(){
        System.out.println("중학생은 공부와 노는것을 병행해야 한다!");
}

@Override
    public void play(){
        System.out.println("고등학생은 수능 준비를 해야한다!");
}
````

아래와 같이 부모의 play()메서드를 가져와서 초등학교,중학교,고등학교에서 각각의 메서드를 오버라이딩 했다. 이것을 메인에서 다형성 없이 사용해보겠다.

````java
ElementarySchool elementarySchool = new ElementarySchool();
MiddleSchool middleSchool = new MiddleSchool();
HighSchhol highSchool = new HighSchool();

elementarySchool.play();
middleSchool.play();
highSchool.play();
````

다형성이 없다면 위와 같이 모든 객체에 해당하는 메서드를 .(dot)을 찍어 호출해야 한다. 하지만 객체지향의 장점이 변화에 용이하고 그러한 객체지향의 꽃이
다형성이라고 생각한 이유는 다형성으로 객체지향의 변화의 용이성이 설명되기 때문이다.

잡설이 길었는데, 다형성으로 위 코드를 리팩토링 한다면

````java
public static void playSchool(School school){
    school.play();
}
````
먼저 위와 같은 메서드를 선언하고 매개변수로 부모 타입을 넣어준다. 부모타입을 넣는 이유는 **다형적 참조**로 인해서 부모타입 객체를 매개변수로 선언시 하위 타입까지
매개변수로 같이 이용할 수 있다는 점 때문이고 매서드 본문에 school.play() 는 다형적 참조로 인해 들어온 객체중에 **메서드 오버라이딩**이 되어있다면 하위 타입의 객체의
메서드를 사용하려고 하기 때문에 우리가 원하는 자식 객체에 따른 다른 메서드를 호출 하는 방식이 완성 된다.

즉 본문에서

````java
playSchool(middleSchool);
````

을 하게 되면 결과값으로

> 중학생은 공부와 노는것을 병행해야 한다!

가 나오는 것이다.

결과적으로 위와같이 매개변수로 들어간 객체 타입에 해당하는 오버라이딩 된 메서드가 출력된다. 이로써 짧은 예제지만 다형성을 이용한 활용을 살펴 보았다.

잡설도 있었고, 장황하게 길게 설명했지만 다형성의 본질은 **자신과 다른 타입 객체로 변할수 있는 능력**이라는 문장으로 요약된다.

<br><br>

## 결론

---

1. 다형성은 객체지향의 꽃이자 변화에 대응하기 좋은 특징이다.
2. 다형성에는 다형적 참조와, 메서드 오버라이딩 이라는 중요한 기능이 있다.
3. 다형적 참조와 메서드 오버라이딩을 이용한 설계는 변화에 대응하기 좋기 떄문에 잘 익혀야 한다.
















