---
title: 관리형 쿠버네티스 GKS를 곁들인
tags: 인프라 도서
article_header:
type: cover
---

## 사전 준비

---

1. minikube 설치
2. kubelctl CLI 설치

<br><br>

## 왜 GKE 인가?

---

**쿠버네티스 인 액션** 에서 GKE를 사용하기도 하지만, 기존 인프라 플랫폼은 AWS 환경만 구축해보았고,
이참에 다른 플랫폼에서의 경험도 해보고 싶어서 책의 플로우를 따라 갈려고 한다.

또한, 기술 내적으로 GKE와 같은 관리형 솔루션을 사용하면 모든 클러스터 노드와 네트워크를 수동으로 설정할 필요가
없어지며, 처음 기술을 접한 나에게 좋은 학습 경험을 제공함과 동시에 이후에 다른 환경으로 마이그레이션을 할 과제까지 생겨
좋다고 생각하였다.

<br><br>

## 기본 설정

---

![](https://cloud.google.com/kubernetes-engine/docs/deploy-app-cluster?hl=ko)

기본적인 가이드는 구글 가이드에 친절하게 나와있으니 따라가면 될것이다. 책에서는 구글 플랫폼 내부 터미널을 사용하지만,
가능한 로컬환경에서 sdk를 설치한 후 로컬 cli에서 실행하는것이 더 좋아보인다.

<br><br>

## 클러스터의 개념 이해하기

---

![](https://raw.githubusercontent.com/jickDo/picture/master/Book/K8s_in_action/k8s_cluster_arch.png)

[사진출처](https://www.argopacific.io/blog/post/architecture-of-kubernetes-cluster)

클러스터의 대한 전체적인 틀은 사진을 확인하는것이 좋다. 각 노드는 도커, Kubelet ,kube-proxy를 실행한다.

kubectl 클라이언트 명령어는 마스터 노드에서 실행중인 쿠버네티스 API 서버로 REST요청을 보내 클러스터와 상호작용한다.

<br><br>

### 클러스터 노드를 조회해 클러스터 동작 상태 확인하기

---

````
kubectl get nodes
````

<br>

![](https://raw.githubusercontent.com/jickDo/picture/master/Book/K8s_in_action/get_nodes.png)

<br>

더욱 자세한 정보를 보고싶다면

````
kubectl describe node <id>
````

위 cli를 입력하면 CPU, 메모리, 시스템 정보, 노드에 실행중인 컨테이너 등을 포함한 정보를 보여주지만,

결과가 상당히 길고 어렵기 때문에 신중하게 사용해야 한다.

<br><br>

## 쿠버네티스로 간단한 어플리케이션 실행하기

---

흔히 배포를 수행할 때 많이 사용하는 방법은 **JSON**이나, **YAML** 매니페스트 파일에 수행할 동작을 작성한 후,
일정한 동작을 반복적으로 수행할 수 있도록 해야한다. 하지만 연습과정이기 때문에 CLI로만 어플리케이션을 띄우보겠다.

<br><br>

### 명령어줄로만 어플리케이션 구동하기

---

````
kubectl run <클러스터명> --image=<도커허브내부이미지> --port=<포트번호> --generator=run/v1
````

위 명령어를 간단히 설명하면, 특정 클러스터에 지정한 이미지를 지정한 포트로 수신대기를 시킨다. 마지막 generator의 경우는
**레플리케이션컨트롤러** 라는 것을 생성하기 위해 사용하는데 이는 2장 뒷부분에서 다룬다.

<br><br>

## 파드란?

---

쿠버네티스는 컨테이너 단위를 어플리케이션을 다루지 않는다. 대신 함께 배치된 다수의 컨테이너라는 개념을 사용한다.
이 컨테이너의 그룹을 **파드**라고 한다.

**파드는** 하나 이상의 밀접하게 연관된 컨테이너의 그룹으로 같은 워커 노드에서 같은 리눅스 네임스페이스로 함께 실행된다.

애플리케이션은 단일 컨테이너로 실행되는 단일 프로세스일 수도 있고, 개별 컨테이너에서 실행되는 주 애플리케이션 프로세스와 부가적으로 도와주는
프로세스로 이뤄질 수 있다.

**파드**에서 실행중인 모든 컨테이너는 동일한 논리적인 머신에서 실행하는 것처럼 보이지만, 다른 파드에 실행중인 컨테이너는 같은 워커 노드
안이라고 할지라도
다른 머신에서 실행 중인 것으로 나타낸다.

**파드**는 고유한 **IP**와 하나 이상의 실행하는 컨테이너를 가진다. 이러한 **파드**는 다른 워커 노드에 퍼져있다.

<img src="https://raw.githubusercontent.com/jickDo/picture/master/Book/K8s_in_action/pod.png" width="400" height="300" />

<br><br>

## 파드 조회하기

---

컨테이너는 쿠버네티스가 관리하는 독립적인 오브젝트가 아니기 때문에 따로 조회할 수없다. 그렇기 때문에 최소단위인 파드를 조회해야한다.

````
kubectl get pods
````

위 명령어를 수행하면

![](https://raw.githubusercontent.com/jickDo/picture/master/Book/K8s_in_action/get_pods.png)

사진처럼 현재 실행중인 파드들을 확인가능하다. 이전 노드에서 그랬던것처럼 **kubectl describe pod**도 가능하다.

<br><br>

## 웹 어플리케이션에 접근하기

---

실행중인 파드에 접근하려면 **서비스**라는 것이 필요하다.

각 파드는 자체 **IP**를 가지고 있지만, 이 주소는 클러스터 내부에 있으며 외부에 접근이 불가능하다. 따라서 **서비스**를 생성하여 (
여기서는 **Load Balancer** 유형)의
서비스를 필요로 한다.

**LoadBalancer**형태의 서비스를 생성하면, 외부 로드 밸런서가 생성되므로 로드 밸런서의 퍼블릭 **IP**를 통해 파드에 연결할 수
있다.

<br><br>

## 서비스 오브젝트 생성하기

---

서비스를 생성하기 위해 쿠버네티스에게 앞서 생성한 레플리케이션컨트롤러를 노출하도록 명령해야 한다.

````
kubectl expose rc <클러스터명> --type=LoadBalancer --name <서비스명칭>
````

<br><br>

## 서비스 조회하기

---

````
kubectl get services
````

위와 같은 명령어를 입력하게 되면,

![](https://raw.githubusercontent.com/jickDo/picture/master/Book/K8s_in_action/get_services.png)

사진처럼 현재 생성되어있는 서비스들이 출력된다.

<br><br>

## 쿠버네티스의 시스템 간략하게 보기

---

**쿠버네티스 인 액션**의 첫번째 장인만큼 쿠버네티스를 전반적으로 살펴 보았다. 마지막으로 이를 간략하게 정리하면서 넘어가려고 한다.

쿠버네티스를 물리적 관점이 아닌, 논리적 관점으로 보게 된다면 **파드**, **레플리케이션컨트롤러**, **서비스** 등이있고
추가적인 내용은 차후에 살펴보고 앞선 언급했던 3가지의 기능의 논리적 구조를 보겠다.

<br><br>

### 레플리케이션 컨트롤러, 파드, 서비스가 서로 동작하는 방식

---

### pod와 레플리케이션컨트롤러 관계

<br>

기본 도커 환경과 달리 인프라 개발자는 k8s를 사용할때 최소 접근을 컨테이너 단위로 하지 않는다.
그 대신에 **pod**라는 것을 생성하고 내부에 원하는 만큼의 컨테이너를 담아두고 실행시킬수 있다.

하지만, **pod**라는 최소단위 또한 인프라 개발자의 담당이 아닌, k8s의 관리 영역이다. 즉 **pod**를 관리자가 생성하는게 아닌
역할을 **레플리케이션컨트롤러**에 위임하게 된다.

즉

````
kubectl run ~~
````

이라는 명령어를 수행하게 되면 **pod**보다 **레플리케이션 컨트롤러**가 먼저 생성되고, 이 **레플리케이션 컨트롤러**가 **pod**를
생성한다.

<br><br>

### 서비스의 필요성

<br>

서비스의 필요성을 알기 위해서는 쿠버네티스에서 pod가 **일시적**이라는 특성을 가진것을 이해해야 한다.

파드는 언제든 사라지고 생기기를 반복한다. 장애로 인한 자가 복구일수도 있고, 누군가가 삭제한 경우일수도 있다. 어떻든 간에 이러한
과정은 **레플리케이션 컨트롤러**가 담당해서 관리하게 된다. 하지만 이러한 과정에서 새로운 pod는 새로운 ip주소를 할당받는다.

즉, 매번 pod에 변화가 생길때마다 ip가 변하고, ip가 변한다는 것은 외부에서 접근이 힘들다는 것을 의미하므로, 이를 하나로 통합하는
진입점을 만들어 줘야 한다.

그것이 **서비스**의 존재 이유다.

**서비스**는 생성되면 지워지지 않는한, **정적 ip**를 할당받고 사용자는 서비스의 **정적 ip**를 통해서 진입한다.
요청이 들어오면 **서비스**는 자신과 연결된 **pod**들중 하나로 연결해 요청을 처리한다.

![](https://raw.githubusercontent.com/jickDo/picture/master/Book/K8s_in_action/k8s_pod_survice_rel.png)

<br><br>

### 레플리케이션 컨트롤러는 어떻게 pod를 관리할까?

---

**래플리케이션 컨트롤러**는 두가지 상태를 가지고 이를 통해 **pod**를 관리한다.

1. DESIRED(열망 상태)
2. CURRENT(현재 상태)

열망상태란 **래플리케이션 컨트롤러**가 특정 **pod**를 열망상태에 표시된 숫자만큼 복제하고 유지하여야 하는 상태이며, 현재 상태는
자신이 현재 관리하고 있는 **pod**의 상태이다.

즉, DESIRED == CURRENT 가 안정된 상태인것이다.

<br><br>

### 파드 조회시 스케줄링된 노드의 정보를 불러오고 싶다면?

---

이전까지 파드정보를 조회할때는

````
kubectl get pods
````

명령어를 사용했다. 하지만, 위정보는

![](https://raw.githubusercontent.com/jickDo/picture/master/Book/K8s_in_action/get_pods.png)

<br>

어떠한 노트에 스케줄링된지 알수없기에 아래와 같은 명령어를 사용하는 것을 알고있어야 한다.

<br>

![](https://raw.githubusercontent.com/jickDo/picture/master/Book/K8s_in_action/get_pods_wide.png)

<br>

위 처럼 입력하면 **파드 IP**와 실행중인 **노드**를 표시한다.

