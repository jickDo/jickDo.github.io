---
title: 트랜잭션과 병행제어
tags: 데이터베이스, 도서
article_header:
type: cover
---
# [1] 병행제어

---

<br><br>

## 1-1. 병행 수행과 병행 제어

---

DBMS는 여러 사용자가 데이터베이스를 동시에 공유할 수 있도록 여러개의 트랜잭션이 동시에 수행되는 **병행 수행**을 지원한다.
또한, **병행 수행**은 여러개의 트랜잭션이 동시에 수행되는 **인터리빙**을 지원한다.

여러 트랜잭션이 병행 수행되면서 같은 데이터에 접근하여 연산을 실행하더라도, 문제가 발생하지 않고 정확한 수행 결과를 얻을 수 있도록
트랜잭션의 수행을 제어하는 것을 **병행제어** 혹은 **동시성 제어**라고 한다.


<br>

### 키워드

* 병행수행
* 인터리빙
* 동시성 제어(병행제어)

<br><br>

## 1-2. 병행 수행의 문제

---

병행 수행에는 대표적인 3가지 문제가 있다

### 1. 갱신 분실

---

하나의 트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써 변경 연산이 무효화 되는 것이다.

<br><br>

### 2. 모순성

---

하나의 트랜잭션이 여러 개의 데이터 변경 연산을 실행할 때 일관성
없는 상태의 데이터베이스에서 데이터를 가져와 연산을 실행함으로써 모순된 결과를 발생시키는것이다.

<br><br>

### 3. 연쇄 복귀

---

연쇄 복귀는 트랜잭션이 완료되기 전에 장애가 발생하여 **rollback**연산을 수행하면, 이 트랜잭션이 장애 발생 전에 변경한 데이터를 가져가 변경 연산을
실행한 또 다른 트랜잭션에도 **rollback** 연산을 연쇄적으로 실행해야 한다는 점이다.

즉 장애가 발생한 지점에서 그와 연관된 다른 연산을 **rollback**을 하고싶지만, 그 연관된 연산이 **commit**이 된경우에는
**rollback**을 시키지 못한다는 문제이다.


<br><br>

## 1-3. 트랜잭션 스케줄

---

트랜잭션을 병행수행 하면 **인터리빙**방식을 사용한다. 그렇기 때문에 트랜잭션 연산 실행 사이에는 **순서**가 매우 중요하다.

**트랜잭션 스케줄**은 트랜잭션에 포함되어 있는 연산을 수행하는 **순서**이다.

**트랜잭션 스케줄**의 종류는 아래와 같다.

| 트랜잭션 스케줄  | 의미                                         |
|-----------|--------------------------------------------|
| 직렬 스케줄    | 인터리빙 방식을 이용하지 않고 트랜잭션별로 연산들을 순차적으로 실행시키는 것 |
| 비직렬 스케줄   | 인터리빙 방식을 이용하여 트랜잭션들을 병행해서 수행시키는 것          |
| 직렬 가능 스케줄 | 직렬 스케줄과 같이 정확한 결과를 생성하는 비직렬 스케줄            |


<br><br>

### 직렬 스케줄(serial schedule)

---

직렬 스케줄(serial schedule)은 인터리빙 방식을 이용하지 않고 트랜잭션별로 연산들을 순차적으로 실행시키는 것이다.
트랜잭션이 직렬 스케줄에 따라 수행되면, 모든 트랜잭션이 완료될 떄 까지 다른 트랜잭션의 방해를 받지 않고 독립적으로 수행된다.

하지만, 정확한 결과를 얻을 수 있지만 **인터리빙 방식**을 사용하지 않고 수행하기 때문에 **병행 수행**이라고 할 수 없다.

<br><br>

### 비직렬 스케줄(non serial schedule)

---

비직렬 스케쥴(nonserial schedule)은 **인터리빙** 방식을 이용하여 트랜잭션을 병행수행 시키는 것이다. 하지만 여러 트랜잭션을 병행
수행하게 되면 갱신 분실, 모순성, 연쇄 복귀 등의 문제가 발생할 수 있어 최종 수행 결과를 보장할 수 없다.

<br><br>

### 직렬 가능 스케줄(serializable schedule)

---

비직렬 스케줄을 직렬 스케줄에 따라 수행한 것과 같이 정확한 결과를 생성하는 스케쥴이다. 모든 비직렬 스케줄이 직렬 가능한 것은
아니다.

<br><br>

### 그럼 어떤 스케줄을 사용해야 할까?

---

트랜잭션이 항상 같은 결과를 내는 **직렬 스케줄**의 장점과, 트랜잭션을 **인터리빙** 방식으로 **병행수행**하는 방식을 섞은
**직렬 가능 스케줄**을 사용할 방법을 찾아야 한다.

하지만, 매번 여러 트랜잭션을 직렬 가능여부를 판단하는 것은 어렵기 떄문에, 직렬 가능성을 보장하는 **병행 제어 기법**을 사용한다.

<br><br>

## 1-4. 병행 제어 기법

---

병행 제어 기법은 여러 트랜잭션을 병행 수행하면서도 정확한 결과를 얻을 수 있는 직렬 가능성을 보장받기 위해 사용한다. 병행 제어
기법의 기본원리는 모든 트랜잭션이 따르면 직렬 가능성이 보장되는 나름의 규약을 정의하고, 트랜잭션들이 이 규약을 따르도록 하는것이다.

그렇기 떄문에 **직렬 가능 스케줄**인지 검사할 필요없이 주어진 규약을 따르면 자동으로 **직렬 가능성**을 보장할 수 있다.

<br><br>

## 로킹 기법

---

로킹 기법은 병행 수행되는 트랜잭션들이 동일한 데이터에 접근하지 못하도록 **lock** 과 **unlock**이라는 2개의 연산을 이용해 제어한다.

**로킹 기법**의 기본 원리는

> 한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 모두 마칠 때까지, 상호 배제(mutual exclusion)하여 직렬가능성을 보장한다.

* lock 연산 -> 독점권 획득
* unlock 연산 -> 독점권 반납


<br><br>

**로킹 기법**의 기본 플로우는

> 1. 한 트랜잭션이 **read** or **write** 연산을 수행하기 위해, **lock** 연산을 실행하여 독점권을 부여 받는다.

> 2. 다른 트랜잭션은 이미 **lock**연산이 수행된 데이터에 한해서 **lock**연산을 수행할수 없기 때문에 그동안 접근할수 없다.

> 3. **lock**연산을 수행한 트랜잭션은 모든 연산을 수행한 후 **unlock**연산을 수행하여 독점권을 반환한다.

<br><br>

### lock 연산의 종류

---

| 연산                 | 설명                                                                                                                |
|--------------------|-------------------------------------------------------------------------------------------------------------------|
| 공용(shared) lock    | 트랜잭션이 데이터에 대해 공용 lock 연산을 실행하면, 해당 데이터에 read연산을 실행할수 있지만 write연산을 수행할 수 없다. 해당 데이터에 다른 트랜잭션도 공용 lock 연산을 수행할수 있다. |
| 전용(exclusive) lock | 트랜잭션이 데이터에 전용 lock연산을 실행하면 read, write연산 모두 실행할 수 있다. 하지만 다른 트랜잭션은 어떤 lock연산도 수행할수 없게 된다.                         |

<br>

공용 잠금은, 공유 잠금 혹은 S_lock이라고도 부른다. 이 연산을 수행하게 되면 lock을 수행한 트랜잭션이 **read**만 수행가능 하며,
다른 트랜잭션이 여기서 동시에 S_lock을 거는것이 가능하다.

반면에, 전용 잠금은 베타 잠금 혹은 X_lock이라고도 부른다. 이 연산을 수행하게 되면 lock을 수행한 트랜잭션이 **read** , **write**연산
모두 수행가능하지만, 다른 트랜잭션은 어떠한 **lock**도 걸지 못한다.

<br><br>

### lock 연산의 양립성

---

|         | 공용 lock | 전용 lock |
|---------|---------|---------|
| 공용 lock | 가능      | 불가능     |
| 전용 lock | 불가능     | 불가능     |

<br><br>
<br><br>

## 2단계 로킹 규약

---

기본적인 로킹 규약만 사용한다면 트랜잭션의 직렬 가능성을 보장하기 힘들다. 그렇기 때문에 새롭게 추가된 규약이
**2단계 로킹 규약(2PLP)** 이다.

> 2단계 로킹 규약은 이름을 들었을 때, 첫번째 규약 이후에 생긴 규약이여서 **2단계 로킹 규약**인것 같지만,
> 사실 **확장**, **축소** 라는 두개의 명확한 **Phase**가 존재해서 **2단계 로킹 규약**이다.


<br><br>

### 확장 단계

> 트랜잭션이 lock 연산만 실행할 수 있고, unlock 연산은 실행할 수 없는 단계

### 축소 단계

> 트랜잭션이 unlock 연산만 실행할 수 있고, lock 연산은 실행할 수 없는 단계


<br><br>

하지만 2단계 로킹 규약 또한 **데드락**이라는 문제를 가지고 있기 때문에, 주의해야 한다.










