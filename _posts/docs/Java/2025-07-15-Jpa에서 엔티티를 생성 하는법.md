---
title: 많이 나오지만 어색한 친구 "리플렉션"
tags: 자바
article_header:
type: cover
---

# Jpa는 어떻게 엔티티를 생성할까?

---

이런 문장들은 본적이 있을것이다.

> **Jpa**는 1차캐시를 조회 후 값이 없다면 데이터베이스에서 값을 조회 후 엔티티를 생성하고 그 값을
> 1차 캐시에 저장후 리턴한다.

그렇다면 여기서 의문이 들 수 있다. **엔티티를 생성한다?.**

<br>
<br>

우리가 흔히 자바에서 **객체**를 생성하기 위해서는 **생성자**를 만들고, **new** 키워드를 통해 객체를 생성한 후
필요한 값을 담아 **객체**를 생성한다.

그런데 **Jpa**는 그냥 값을 조회하고 보여주는 것이 아닌 조회한 값을 통해 **엔티티**라는 **객체**를 생성 하는것이다.

**이게 어떻게 가능할까?**

정답은 바로 **리플렉션**이다.

<br>
<br>

# 리플렉션

---

**리플렉션**은 자바에서 런타임에 값을 조사하고, 값을 변경할 수 있는 기능이다. 실제로 **클래스명**, **생성자**, **생성자 파라미터**, 등등
정말 많은것을 조사할 수 있다.

그런데, **왜?** 런타임에 이러한 값을 조사하고 조작하는 기능이 생겨나게 되었을까?

어짜피 런타임에 동적으로 바뀌는게 아니라면 컴파일 시점에 정보와 런타임 시점에 정보가 같을건데 말이다.

<br>
<br>

이렇게 **리플랙션**을 사용하는 의문이 들지만, 간단하게 생각하면 런타임 시점까지 소스코드의 정보를 알기 어려운 경우가 있기 때문이다.
이러한 경우는 보통 외부에서 내 소스코드에 접근하거나 정보를 조회 수정하는 경우에 대해서는 **컴파일**시점에 그 값을 알기 어렵기 떄문이고,

이러한 케이스에 해당하는 경우가 흔히 사용하는 **프레임워크**, **라이브러리**를 사용하는 경우이다.

이러한 일련의 이유 떄문에 **프레임워크**와 **라이브러리**에서는 흔하게 나오는 개념이고, 실제 자신이 만질수 있는 프로젝트 범위에서는
보기힘든 기능이다. **스프링이 실행시점에 빈을 주입** 하는 케이스나, **Jpa에서 기본생성자를 필요로 하는 경우** 가 모두 리플렉션의 영향이다.

<br>
<br>

## Jpa가 기본 생성자를 필요로 하는 경우

---

사실 이글을 쓰게 된 이유가 **Jpa**를 공부중 **기본 생성자**가 반드시 필요하다는 내용을 공부하다가 **리플렉션**까지 넘어오게 된것이다.

그렇다면 **리플렉션**이 어떻게 작동하는지 알기 위해 실제 리플렉션을 사용해보 겠다.

<br>
<br>

````java
public class Animal {

	public int height;
	public int weight;

	public void move(){
		System.out.println("멍멍");
	}

	public Animal(){

	}

	public Animal(int height, int weight) {
		this.height = height;
		this.weight = weight;
	}
}
````

이러한 동물이라는 클래스를 생성하고 두개의 생성자를 만들어 두었다.

이제 이것을 리플렉션을 통해 조회 한다면 어떻게 나올까?

<br>
<br>

````java
class main {
  @Test
  public void getClassByReflection() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
    Object obj = new Animal();

    Class<?> objClass = obj.getClass();

    Constructor<?>[] constructors = objClass.getDeclaredConstructors();
    System.out.println(Arrays.toString(constructors));

    Constructor<?> constructor = constructors[1];
    System.out.println(constructor);


    Parameter[] parameters = constructor.getParameters();

    System.out.println(Arrays.toString(parameters));
  }
}
````

<br>
<br>

> [public com.example.juststudy.Animal(), public com.example.juststudy.Animal(int,int)]
> public com.example.juststudy.Animal(int,int)
> [int height, int weight]

값이 이렇게 조회되는 것을 알수 있고, 처음 말했던 것처럼 클래스의 정보를 조회하는게 가능하다.

그런데 여기서 **한가지 의문**이 들었다.

많은 기술 블로그에서 **Jpa**가 기본생성자를 필요로 하는 이유가 **리플랙션**은 **생성자의 파라미터 정보**를 가져오지 못함 이라고들 설명한다.

처음에는 나도 그렇게 믿고 있었는데 위와 같은 결과에서 이상한 점이 있다.

<br>
<br>

> [int height, int weight]

<br>

이게 생성자의 파라미터 정보아닌가? 자료형이랑 이름까지 정확하게 나온다. 그렇다면 기본 생성자가 없어 **Jpa**는 **객체**를 생성할 수 있어야 하는거 아닌가?

이 의문은 몇가지 추측으로 **Jpa**가 기본생성자를 강제 하는 이유를 유추 해 볼 수 있다.

<br>
<br>

첫번째는, 생성자가 **복수**개일경우 **Jpa**는 어떤 생성자를 선택해야 하는지 알 수 없다. 이러한 경우 첫번째 생성자를 선택하게 하는등
해결할 수 있겠지만, 이렇게 구현하였을때 고려하여야 하는 부분이나, 사용자가 불편함을 겪을 경우에 대한 부분이 기본생성자를 강제하는 것으로
해결할 트레이드 오프랑 비교했을때 **기본 생성자**의 사용이 깔끔하기 때문이라고 생각한다.

<br>
<br>

두번째는, **복수개**의 파라미터가 **타입**까지 같을때 필드 변수의 이름과 파라미터의 이름을 일치 시켜 두지 않으면 **Jpa**입장에서
이걸 구분할수 있는 능력이 없다는 것이다.

<br>
<br>

위와 같은 이유에서 **기본 생성자**를 강제 하지 않을까? 생각한다.

<br><br>

## 결론

---

1. 자바에는 리플렉션이 존재한다.
2. 리플렉션은 라이브러리나 프레임워크 처럼 외부에서 클래스 정보를 알아야 하는경우 사용한다.
3. Jpa는 실제 생성자의 파라미터 정보를 가져올 수 있지만 Jpa가 기본생성자를 강제한다.

<br><br><br>



