---
title: HTTP의 기본
tags: 웹
article_header:
type: cover
---

# 💻 HTTP의 기본

## 🛠 HTTP의 역사

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/1HTTP의역사.png)

> HTTP는 현재 3버전 까지 진화를 거듭하였지만 HTTP 1.1이 가장 중요한 버전이다. 이유는 1.1에서 현재 우리가 사용하는 많은 기능이 추가가 되었고, 이후에는 성능 위주로 개선이 되었기 때문이다.

---

# 💻 클라이언트 서버

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/2클라이언트.png)

HTTP는 클라이언트 서버 구조를 가진다. 클라이언트는 서버에 요청을 보내고, 응답이 돌아올때 까지 기다리게 된다. 응답이 오게 되면 그것을 해석하여 클라이언트가 동작하게 된다.

## ❓ 왜 클라이언트 서버 구조가 중요한가!?

> 클라이언트 서버 구조는 예전에는 하나의 덩어리처럼 있었다고 한다. 하지만 클라이언트 서버를 개념적으로 분리를 하게 되면서 각각 독립적인 진화가 가능하게 되었다.
> 클라이언트는 ui/ux, 사용성에 초점을 맞추게 되었고, 서버는 비지니스 로직같은 복잡한 개념을 담아둘 수 있었다.

---

# 💻 무상태성 (Stateless)

-   무상태성이란 무엇일까?
-   무상태성이란 서버가 클라이언트의 상태를 보존하지 않는다는 것이다.
-   상태성이란 무엇일까?
-   서버가 클라이언트의 상태를 보존하는 것이다.

사실 텍스트만 보고 이 둘을 이해하기는 힘든것같다.

그래서 예시를 하나 들어 보겠다.

## 🧩 Stateful

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/3무상태성.png)

1번 예시를 보면 점원은 노트북에 대한 상태를 저장하게 될것이다. 이 때문에 2번 예시에서 고객이 2개라고 말을 해도 그것이 노트북에 대한 상태인것을 알고 대답을 하는 것이다. 그리고 2번 예시또한 2개라는 수량과 이전의 노트북 상태를 저장하고 있다. 3번 예시를 통해 노트북, 수량, 신용카드의 상태를 저장하게 된다.

## 🧩Stateless

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/4무상태성.png)

Stateful과 다르게 Stateless는 이전의 상태를 기억하지 못하기 때문에 매번 답변에 답변을 더해 전달하는 것을 볼 수있다.

> **여기까지 보면 Stateful이 좋아보인다. 근데 Stateless가 HTTP방식의 특징으로 불리는데는 단점만이 아닌 장점의 요소가 있겠거니 생각을 하게 되었다.**

> 강의에서 이러한 궁금증을 풀어 주었다. 만약에 점원이 바뀐 상황이라면 어떻게 될까라는 질문을 하셨다.
> 그때서야 장애점이나 점원이 바뀐상황에서는 Stateless가 훨씬 효율적이라는 것을 알게 되었다.

### 🧩Stateful의 점원 바뀜

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/5무상태성.png)

Stateful에서는 점원이 바뀌게 된다면, 정상적인 대화가 진행이 힘든것을 확인할 수 있다.

### 🧩Stateless의 점원 바뀜

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/6무상태성.png)

Stateless에서는 점원이 바뀌게 되어도 정상적인 대화가 진행되는 것을 확인할 수 있다. 이유는 고객이 매 질문마다 이전 정보의 추가되는 정보를 담는 방식으로 대화를 진행하기 때문이다.

## 🔑 Stateful && Stateless의 차이점 정리

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/7무상태성vs상태성.png)

> 이처럼 점원이 바뀐경우라면 상태 유지는 문제가 생기게 된다. 이를 확장하여 생각하면 서버입장에서 트래픽이 몰려서 새로운 서버를 추가해야 한다면, 상태 유지는 큰 문제가 될것이다. 이유는 항상 같은 서버를 유지해야하는 상태 유지특성상 서버가 바뀌면, 처음부터 응답, 호출을 시행하여 한다.
> 이와 반대로 무상태성은 새로운 서버가 추가되도 전혀 무리없이 하던것을 진행하면된다.

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/8무상태성.png)

> 이와 같은 이유 때문에 무상태성은 수평적 확장이 유리하다.

---

## ❗️ 무상태성의 실무 한계

모든 것을 무상태성으로 설계 하는 것은 현실적으로 불가능하다. 단순한 서비스 소개화면 같은 것들만 서비스를 한다면 가능하겠지만, 현실의 서비스는 보다 복잡한 구조나 로그인과 같은 상태를 유지하고 있어야 하는 것들이 존재한다. 일반적으로 이러한 로그인 같은 경우는 세션이나 쿠키와 같은 것들을 이용해서 상태를 유지하지만 상태 유지의 특성상 최대한 자제하면서 사용하도록 해야한다.

---

# 💻 비연결성(Connectionless)

-   연결성이란 무엇일까?

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/9비연결성.png)

```
지금까지 공부한 클라이언트-서버 환경에서 요청과 응답을 하게 되면 그림처럼 연결이 되게 된다.

클라이언트는 요청을하고 서버가 그것을 응답하면서 연결이 된다.

그림처럼 클라이언트가 3개 일때 모두 서버와 연결이 된 상태라면 서버 입장에서는 3개의 클라이언트의 연결을 계속 유지하여야 하는 부담이 있다.

클라이언트가 3개라면 다행이지만, 만약에 백단위 천단위 만단위 트래픽이 몰리는 상황이라면 서버는 상당한 리소스를 소모하거나 멈추는 일이 발생할것이다.
```

-   비연결성이란 무엇일까?
-   연결성의 이러한 문제 때문에 HTTP는 비연결성을 따른다.

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/10비연결성.png)

```
그림처럼 요청과 응답 이후에는 클라이언트-서버 연결을 종료 시키는 방법을 사용한다.

이렇게 되면 서버 입장에서는 필요할때만 연결을하고 이후에 연결을 종료시키기 때문에 최소한의 자원만을 사용하게 될것이다.

현실의 서비스로 넘어오게 되면, 수천명이 서비스를 사용한다 하여도 동시에 처리하는 요청은 수십개로 감소하게 될것이다. 그렇게 되면 자원을 최소한으로 사용하게 되는 것이다.
```

### ❓ 그럼 비연결성의 한계도 있을거 같은데…

당연히 장점이 있다면 단점도 있을것이다.

비연결성의 단점들을 설명해보자면

1.  매 요청마다 TCP/IP연결을 새로 맺어야 하기때문에 3 way handshake 시간이 추가된다.
2.  웹 브라우저로 연결을 할때는 HTML뿐만 아니라, 자바스크립트 ,css, 추가이미지등 수 많은 자원이 함께 다운로드 된다.

이러한 단점들이 있지만 언제나 그래왔듯이 그것을 극복하는 방법또한 탄생하였다….

# 💻 지속 연결 (Persistent Connections)

지속 연결을 설명하기전 초기의 HTTP에서 비연결성을 이용한 예시를 하나 보이겠다.

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/11지속연결.png)

이것이 초기의 HTTP의 비연결성 통신 방식이고, 매번 연결과 종료를 하게 되어, 총합 0.9초의 시간이 들게 된다.

그렇다면 지속연결은 HTTP에서 어떤 방식으로 통신을 하게 될까?

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/12지속연결.png)

위 그림처럼 연결을 한 후 필요한 모든 응답을 처리 한 후 종료를 하게 된다.

이러한 특성 때문에 매번 연결과 종료를 하는 시간을 줄이게 되어 이전 비연결성인 상태보다 눈에 띄게 시간이 준것을 확인할 수 있다.

---

# 💻 HTTP 메시지

## 🛠 HTTP 메시지의 구조

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/13http메세지.png)

HTTP 메시지의 구조는 그림처럼 생겼고, 이것이 응답과 요청에서 큰틀로는 작용하지만 안에 들어가는 구조가 다르다. 이를 아래에서 설명하겠다.

## 🧩 HTTP 메시지(요청)

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/14http요청.png)

이러한 형태를 가지며, body 또한 올수있다.

시작 라인에서는 크게 3가지가 와야한다.

1.  HTTP 메서드
2.  요청대상 (절대 경로)
3.  HTTP 버전

## 🧩 HTTP 메시지(응답)

![](https://raw.githubusercontent.com/jickDo/picture/master/Web/cp2/15http응답.png)

### 🧩HTTP 헤더 부분

HTTP 헤더 부분은 여러가지 기능과 특징이 있는게 요약해서 정리하자면

1.  HTTP 전송에 필요한 부가정보
    예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보, 서버 애플리케이션 정보, 캐시 관리 정보…
2.  HTTP 헤더의 표준이 너무 많아서 찾아봐야 함
3.  필요시 임의의 헤더를 추가할 수 있다.

### 🧩HTTP 바디 부분

HTTP 바디 부분은 여러가지 기능과 특징이 있는게 요약해서 정리하자면

1.  실제 전송할 데이터
2.  HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송 가능

출처: _**김영한님 '모든 개발자를 위한 HTTP 웹 기본 지식'**_
