---
title: 프로세스, 프로세스 메모리 구조, PCB
tags: 운영체제
article_header:
type: cover
---

## 프로세스란 무엇일까?

---

우리는 흔히 보조 기억장치에 있는 프로그램 정보를 메모리로 적재하고, 적재된 정보를 CPU가 읽어 사용하는 이 과정을 프로그램이 실행되었다 라고 표현합니다.

여기서 실행된 프로그램을 **프로세스**라는 개별적인 용어로 부르고 프로그램을 실행하는 과정을 프로세스를 생성한다고 표현합니다.

<br>
<br>

![](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp2/7/process_in_mac.png)

<br>
위 사진처럼 보이는 것보다 더 많은 프로세스가 작동하고 있는데, 여기서 사용자가 볼 수 있는 프로세스를 포그라운드 프로세스 라며 명하며,
보이지 않는 프로세스를 백그라운드 프로세스라고 부르게 됩니다.

백그라운드 프로세스라고 해서 사용자와 상호작용하지 않는 다는 뜻은 아닌데 백그라운드 프로세스 중에서 사용자와 상호작용 하지 않고 자신의 일만을 수행하기 위해 존재하는
프로세스를 **데몬(daemon)** 프로세스라고 명합니다.

<br>

## 프로세스 제어 블록(PCB)

---

CPU자원이 한정되어 있는 반면에, 모든 프로세스는 실행을 위해 CPU를 사용하여야 합니다.
그렇기 떄문에 프로세스들은 한정된 시간 만 CPU를 사용하며 자신의 차례를 기다립니다.

운영체제는 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고, 프로세스에 CPU와 여러가지 자원을 배분합니다.
이를 위해 운영체제는 프로세스 제어 블록(PCB)를 이용합니다.

<br>

PCB는 커널 영역에 생성되고, 수많은 프로세스를 PCB를 통해 태그처럼 사용해 특정 프로세스를 식별하며 해당 프로세스를 처리하는데 필요한 정보를 판단합니다.

즉, 가게 주인이 물건을 태그를 통해 판단하고 가격을 알 수 있고, 생산지를 알 수 있는 것처럼 PCB는 운영체제가 수 많은 프로세스를 식별하고 그 프로세스의 정보를 판단하게 돕습니다.

<br>
<br>

## PCB의 구조

---

<br>

![](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp2/7/PCB.png)

<br>

위 그림처럼 PCB는 프로세스를 식별하기 위해 여러가지 정보를 담고 있습니다. 프로세스의 ID나,
레지스터의 값 혹은 상태같이 많은 정보를 담고있으며 이를 알아보고자 합니다.

<br>

### 프로세스 ID

![](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp2/7/process_id.png)

프로세스 ID(PID)는 프로세스를 식별하기 위해 존재하는 고유 ID입니다. 메모장을 두개 킨다고 할지라도 다른 프로세스ID가
만들어지는 것처럼 중복된 활동이여도 하나의 프로세스는 고유한 ID를 가지게 됩니다.

<br>

### 레지스터 값

프로세스는 자신의 실행 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원합니다.
여기에는 프로그램 카운터가 속하게 됩니다.

<br>

### 프로세스 상태

현재 프로세스가 어떤 상태인 기록합니다. 입출력장치를 사용하기 위해 기다리는지 혹은 CPU를 사용하고 있는 상태인지 와 같은
상태를 기록하며 자세한 상태는 다음장에서 설명합니다.

<br>

### CPU 스케줄링 정보

프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보도 PCB에 기록됩니다.

<br>

### 메모리 관리 정보

프로세스마다 메모리에 저장된 위치가 다릅니다. 그렇기 떄문에 PCB에는 해당 프로세스가 저장된 메모리 위치를 기록해야 합니다.

<br>
<br>

## 프로세스의 메모리 영역

---

프로세스가 생성되면 커널 영역에 PCB가 생성됩니다. 그렇다면 커널 영역이 아닌 사용자 영역에는 어떤 데이터가 들어갈까요?

![](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp2/7/memory_model.png)

위 그림처럼 하나의 프로세스는 크게 코드영역(Text), 데이터 영역(Bss,Gvar), 힙 영역(Heap), 스택 영역(Stack) 4가지로 나뉩니다.

차례대로 설명하자면,

<br>
<br>

### 코드영역 or 텍스트영역(Text)

이곳에는 실행할 수 있는 기계어로 이루어진 명령어가 저장됩니다. 가공할 수 있는 데이터가 아닌
CPU가 실행해야 하는 명령어가 담겨있기 때문에 읽기모드만 지원합니다.

<br>

### 데이터 영역

프로그램을 실행하는 동안 유지되어야 하는 데이터가 저장되는 공간입니다. 대표적은 전역 변수가 이곳에 해당합니다.

<br>

### 코드영역 & 데이터 영역 공통점

위 두 영역은 크기가 변하지 않습니다. 프로그램을 구성하는 명령어가 작동중에 코드 양이 늘어나는 경우가 없으니
이 두가지 영역을 정적 할당 영역이라고 부릅니다.

<br>

### 힙 영역

프로그래머가 직접 할당할 수 있는 공간입니다. 프로그래밍 과정에서 힙 영역에 데이터를 할당했다면 언젠가는 이 영역에
데이터를 반환해야 합니다. 그렇지 않다면 메모리 용량은 점점 줄어들어 장애가 발생할 수 있습니다.

이런 문제를 메모리를 할당받고 해제 하지 않았다고 하여 누수가 발생했다. 즉 메모리 누수라고 부릅니다.

<br>

### 스택 영역

스택 영역은 데이터를 일시적으로 저장하는 공간입니다.
데이터 영역에 담기는 값과는 다르게 잠깐 쓸 데이터를 담아두는 공간입니다.
함수를 실행하는 동안 필요한 지역변수, 매개 변수가 이곳에 해당합니다.
그렇기 떄문에 함수가 종료되면 스택 영역에서 해당 함수에 쓰였던 변수들도 같이 없어지게 됩니다.

<br>
<br>

### 힙 영역 & 스택 영역 공통점

위 두 영역은 실시간으로 그 크기가 변할 수 있고 그렇기 떄문에 동적 할당 영역이라고 부르게 됩니다.

그림을 보면 unused memory영역이 있는데, 스택 영역과 힙 영역이 동적이기 떄문에 힙은 아래에서 위로, 스택은
위에서 아래로 주소를 할당하게 됩니다. 그렇게 되면 서로 충돌없이 동적으로 값을 할당할 수 있기 때문입니다.

여기서 만약에 힙이나 스택에 많은 정보가 담겨서 서로의 지점을 충돌 할 수 있는데, 그럴때 각각 stack overflow,
heap overflow라고 부르게 됩니다.


### 출처
[사진출처](https://www.programmersought.com/article/98613694619/)

<br>
<br>
<br>
