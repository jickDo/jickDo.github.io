---
title: 콘텍스트 스위칭, 프로세스 상태 변화, 프로세스 계층과 생성 방식을 알아보기
tags: 운영체제
article_header:
type: cover
---

## 문맥교환(Context Switching)

---
하나의 프로세스에서 다른 프로세스로 실행 순서가 넘어가면 어떤 일이 발생할까요?

프로세스 A가 CPU를 사용하다가 사용 시간이 끝나서 프로세스 B로 넘어간다면, A프로세스의 정보를
저장하여야 합니다. 이곳에서는 이전에 보았던 PCB의 값인 레지스터 값, 메모리 정보등 중간 정보를 저장하여야
이후 자신의 차례가 왔을 때 이 과정을 이어받아 작업을 수행할 수 있습니다.

여기서 하나의 프로세스를 실행하기 위해 필요한 정보들을 문맥(Context)라고 부르게 됩니다.
이러한 문맥값들은 PCB속에 저장됩니다.환

<br>

![](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp2/8/context_switching.png)


결국 프로세스 A에서 B로 프로세스가 넘어가는 순간에 프로세스 A정보를 백업하고 그작업이 끝난다면
프로세스 B의 문맥을 불러오게 되며 이 것이 프로세스를 교대하는 방법입니다.

문맥교환을 통해 여러개의 프로세스가 병렬적으로 시행되는 것 처럼 보이게 하지만 이러한 문맥교환은
오버헤드가 발생할 수 있기 때문에 문맥교환이 자주일어나면 오버헤드를 신경써야 합니다.

<br>
<br>

## 프로세스 상태

---

이전에 PCB에 기록되는 정보 중 프로세스 상태가 있다고 합니다. 여기서 말하는 프로세스 상태는 생성이 되었는지
혹은 CPU를 사용하는지와 같은 정보를 통칭해서 프로세스 상태라고 부르게 됩니다.

<br>

프로세스 상태는 크게 다섯가지로 나뉠 수 있습니다.

[](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp2/8/process_state.png)

<br>

### 1. 생성 상태

프로세스를 생성 중인 상태를 생성 상태라고 부릅니다. 메모리에 적재되어 PCB를 할당받은 상태를 생성상태라고 부르게 됩니다.
생성 상태가 끝난다고 곧바로 실행되는 것이 아닌 준비 상태가 되어 실행되기를 기다리게 됩니다.

<br>

### 2. 준비 상태

준비 상태는 당장 CPU를 할당받아 실행될 수 있지만, 차례가 오지않아 기다리고 있는 상태입니다.
이 상태에서 준비가 되면 실행 상태로 넘어 갑니다. 그리고 다른 상태에서 다시 준비 상태로도 전환이 가능합니다.

준비 상태인 프로세스를 실행 상태로 전환하는 것을 디스패치 라고 부릅니다.

<br>

### 3. 실행 상태

실행 상태는 CPU를 할당받아 실행 중인 상태를 지칭 합니다. 실행 상태인 프로세스는 할당된 시간 동안 CPU를 사용할 수 있습니다.
이때 제한된 시간내 프로세스를 완료하지 못한경우 준비 상태로 전환이 되며, I/O입력처럼 대기해야 하는 상황이 생기면
대기 상태로 넘어가게 됩니다.

<br>

### 4. 대기 상태

실행 상태에서 I/O입력과 같이 프로세스가 대기해야 하는 상황이 온다면 대기 상태로 진입하게 됩니다.
대기 상태가 끝난다고 해도 실행 상태가 되는것이 아닌 준비 상태로 넘어가게 됩니다.

<br>

### 5. 종료 상태

프로세스가 종료된 상태입니다. 이 상태에 도달하면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리합니다.

<br>
<br>

## 프로세스 계층 구조

---

프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있습니다.

이때 새 프로세스를 생성한 프로세스를 부모 프로세스라고 부르게 되며, 생성 된 프로세스를 자식 프로세스라고
부르게 됩니다.
부모의 프로세스와 자식의 프로세스는 각각 고유한 PID를 가지며 자식프로세스에서 부모프로세스 PID를 PPID로 가지고 있기도 합니다.

<br>

[](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp2/8/process_layer.png)

<br>
<br>

## 프로세스 생성기법

---

그렇다면 부모 프로세스가 어떻게 자식 프로세스를 생성 할까요?

그 방법은 fork, exec라는 명령어를 통해서 생성하게 됩니다.

부모 프로세스는 fork를 통해 자신의 복사본을 자식 프로세스로 생성해내고, 그 복사본은 exec명령어를 통해
자신의 메모리 공간을 다른 프로그램으로 교체합니다.

<br>

[](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp2/8/fork.png)

<br>

좀더 자세히 설명하면 fork, exec 모두 시스템 호출로 분류 됩니다.
부모 프로세스는 fork 시스템 호출을 통해 자신의 복사본을 자식으로써 생성합니다.

여기서 자식은 부모의 복사본이기 때문에 부모 프로세스의 자원들, 예를들면 메모리의 내용, 열린 파일의 목록등을
상속하게 됩니다. 그렇다고 해서 모든 정보가 같지는 않습니다.

왜냐하면, PID나 메모리 저장구조는 고유한 정보이기 때문에 fork로 만들어진 자식은 PID, 메모리 저장위치
처럼 고유한 정보에 대해서는 개별적인 값을 가지고 있습니다.

<br>

[](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp2/8/exec.png)

<br>

fork만 사용한 프로세스는 완전한 자식 프로세스라고 명하기는 조금 어렵습니다.
PID와 같은 고유한 값을 제외한다면 부모가 가진 리소스를 동일하게 사용하는 대체품이기 때문입니다.

그렇기 때문에 자식 프로세스는 자신의 프로세스를 가지기 위해 exec 시스템 호출을 하게 됩니다.

exec 호출을 진행하게 되면 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰게 됩니다.

코드 영역과 데이터 영역의 내용이 실행한 프로그램으로 바뀌게 되고, 나머지 영역은 초기화 됩니다.

### 출처
[사진출처](https://yoongrammer.tistory.com/53)

[사진출처](https://thebook.io/080367/0021/)

[사진 출처: 혼자 공부하는 운영체제 저자:강민철]

<br>
<br>
<br>
