---
title: 상호배제와 동기화 기법
tags: 운영체제
article_header:
type: cover
---

## 상호배제(Mutual Exclusion)

---

상호배제(Mutual Exclusion)는 여러 프로세스나 스레드가 동시에 같은 공유 자원에 접근하는 것을 막는 메커니즘입니다.

일상생활에서 비유하면, 화장실 사용과 같습니다.
한 번에 한 사람만 화장실을 사용할 수 있고, 다른 사람들은 기다려야 합니다.
컴퓨터 시스템에서도 마찬가지로 특정 자원은 한 번에 하나의 프로세스만 사용할 수 있어야 합니다.

<br>

## 왜 상호배제가 필요할까?
현대 운영체제는 멀티태스킹 환경에서 여러 프로세스가 동시에 실행됩니다.
이때 프로세스들이 공유하는 자원(메모리, 파일, 데이터베이스 등)에 동시에 접근하면 다음과 같은 문제가 발생할 수 있습니다.

### 1.경쟁 상황(Race Condition)

두 프로세스가 동시에 같은 데이터를 수정하려 할 때, 실행 순서에 따라 결과가 달라지는 상황입니다.
예를 들어, 은행 계좌 잔액을 동시에 업데이트하는 두 거래가 있다면, 최종 잔액이 예상과 다를 수 있습니다.

### 2. 데이터 일관성 파괴

여러 프로세스가 동시에 데이터를 수정하면 데이터의 무결성이 깨질 수 있습니다. 이는 시스템 전체의 신뢰성에 큰 영향을 미칩니다.

<br>
<br>

## 동기화 기법

---

이런 **상호 배제**에 대해 방지하는 방법으로는 **뮤텍스**, **세마포어**, **모니터** 기법이 있습니다.

<br>
<br>

## 뮤텍스 락(Mutex lock)

---

**뮤텍스 락**의 풀네임은 **Mutual Exclusion Lock**입니다. 즉 상호 배제 단어에 lock을 붙인 단어와 일치합니다.

이 말은 상호배제를 구현하기 위해 **Locking**방식을 사용하는 방법입니다.

**뮤텍스 락**은 화장실 사용에 비유해보겠습니다.

![img.png](toilet.png)

<br>

화장실은 한칸에 한사람만 받을 수 있습니다. 칸에 사람이 들어가있다면 해당 칸에 다른 사람이 들어올 수 없습니다.
다른 사람이 들어오는 시점은 먼저 사용하던 사람이 해당 칸을 나가게 되면 사용할 수 있습니다.

이 내용을 설명하는 이유는, 위 방식의 흐름이 뮤텍스 락과 동일하기 때문입니다.

간단한 **뮤텍스락**을 코드를 통해서 보겠습니다.

**자물쇠**에 해당하는 전역변수 하나, 그리고 해당 **자물쇠**를 잠구고, 푸는 두가지 함수만 있으면 구현가능합니다.

<br>
<br>

````java
acquire(){
    while (lock == true){
        .....
        }

    lock = true;
}
````

````java
release(){
    lock = false;
        }
````

<br>

해당 함수들은 차례대로 화장실 문이 잠겼는지 확인하고 잠기지 않았다면 들어가서 잠구는 함수 **Acquire**,
그리고 화장실을 나올때 잠금을 해제 하는 **Release**로 볼 수 있습니다.

이 함수를 아래 수도코드 처럼, 임계 구역 들어가기전, 나온 후 에 사용하게 되면

````java
acquire();
// 임계 구역
release();
````

**lock**여부를 확인 한 후, 들어가도 되면 본인이 **lock**을 걸고 이미 **lock**이 걸려있다면
임계 구역 코드 전에서 계속 기다리게 됩니다.

<br>

### 뮤텍스 락의 단점


하지만, 이런 방식에는 큰 문제가 있는데 **바쁜대기(Busy Wait)** 을 수행하게 됩니다.
명칭 그대로 대기를 하는 상황임에도 바쁘게 행동하는 것을 말하게 됩니다.

**대기**를 하는 상황에 행동을 하는것은 **lock 확인**작업에 **CPU**를 사용하겠다는 것을 의미하고,
이런 기다림은 해당 **lock** 이 풀릴떄까지 지속됩니다. 즉, 비효율적입니다.

<br>
<br>

## 세마포(semaphore)

---

**세마포**는 동기화 방식중 하나입니다. **뮤텍스 락**과 비교하면 공유자원의 갯수를 다루는 방식이 다릅니다.
**뮤텍스 락**은 공유자원이 하나라고 가정하고 라킹을 수행하지만, **세마포**는 공유 자원이 여러 개 있을경우
각 프로세스는 해당 공유자원에 접근이 가능합니다.

마치 공중화장실에서 화장신 칸 수 만큼 공유자원이 있고, 각 칸에 사람이 들어가는 것을 관리하는 방식입니다.

![img.png](semaphore.png)

**세마포**는 사진과 같은 **철도 신호기**에서 유래한 단어 입니다. 그렇기 때문에 철도 신호와 같은 방식을 사용합니다.

**뮤텍스 락**은 공유 자원을 **잠금**, **해제**를 수행하면서 해당 자원을 관리하지만,

**세마포**의 경우 **빨간불**, **초록불** 처럼 가도 되는지, 멈춰야 하는지 상태를 알려줍니다.

**세마포**도 간단하게 코드로 구현이 가능합니다.

먼저 **공유자원의 갯수**를 나타내는 전역 변수 한개와, 임계구역에 들어가도 되는지, 기다려야 할지 알려주는 함수 **Wait**,
그리고 기다리고 있는 프로세스에게 **이제 출발하라**를 나타내는 **Signal**함수가 있습니다.

<br>

````java
wait() {
    while(S <= 0){

        }
    S--;
}
````

````java
signal() {
    S++;
}
````

위 코드를 차례대로 **Wait**, **Signal**함수를 구현한것이고 전역 변수 S의 값이 양수, 즉 사용해도 되는
공유자원이 있을 경우 **Wait**함수의 while문을 탈출합니다.

그 경우 사용가능한 공유 자원 갯수를 하나 줄입니다.

````java
wait();
// 임계 구역
signal();
````

임계 구역을 나오게 되면 signal이 수행될것이고, 사용가능한 자원을 하나 반납하게 될것입니다.

<br>

근데 while문이 있다면 **뮤텍스락**처럼  **바쁜 대기** 상태가 발생할 수 있다는걸 암시하게 됩니다.
하지만 이는 세마포가 **CPU**를 사용하지 않게 구현하며 해결할 수 있습니다.

<br>

## 세마포가 busy wait를 해결하는 방법

---

아래 두가지 함수를 통해서 세마포는 **busy wait**를 해결합니다.

````java
wait(){
    S--;
    if ( S < 0){
        add this process to Queue;
        sleep();
    }
}
````

````java
signal(){
    S++
    if ( S <= 0){
        remove a process p from Queue;
        wakeup(p);
        }
}
````
위 방식은 이전처럼 while문을 통한 접근 가능여부를 체크하는 것이 아닌 만약 접근 불가능 한경우(사용가능한 공유 자원이 없을떄)
해당 프로세스의 **PCB**를 **세마포**를 위한 **대기 큐**에 넣습니다.

프로세스는 대기 큐에 들어가게 되면서 이후 해당 **PCB**를 **준비 큐**로 돌리기 전까지 **CPU**자원을 잡아 먹지 않게 됩니다.

<br>
<br>

## 모니터

---

세마포 기법 자체는 동기화도구로써 좋은 효능을 보여주지만, 사용자 측면에서 불편한 점이 있다.
임계 구역에 앞뒤로 wait, signal 함수를 사용하고 휴먼에러로 인한 실수가 발생한다면 예기치 못한 결과를 발생시킬 수 있기 때문이다.

이에 **모니터**라는 동기화 도구가 생기게 된다.

모니터는 공유 자원과, 공유 자원에 접근하기 위한 인터페이스를 묶어 관리합니다.

<br>

![img.png](monitor.png)

<br>

이를 위해 모니터를 통해 공유 자원에 접근하고자 하는 프로세스를 큐에 삽입하고, 큐에 삽입된 순서대로 하나씩 공유 자원을 이용하도록 합니다.
모니터는 공유 자원을 다루는 인터페이스에 접근하기 위한 큐를 만들고, 모니터 안에 항상 하나의 프로세스만 들어오도록 하여 **상호 배제**를 수행합니다.

또한, 모니터는 **실행 순서**를 제어하는 동기화 또한 수횅합니다. **조건 변수**를 사용해서 실행 순서를 제어하게 됩니다.

<br>

![img.png](monitor2.png)

<br>

해당 그림처럼 기존 **상호 배제를 위한 큐**가 아닌 **조건 변수**에 대한 큐가 있습니다. 이 **조건 변수**는 기존처럼 **wait**, **signal** 연산을
수횅할 수 있습니다.

상호 배제를 위한 큐에서 가장 선두에 있는 프로세스A보다 특정 프로세스B가 더 먼저 시행되어야 한다면, B가 수행되기 전까지 앞선 프로세스들은 **wait** 연산을 통해
조건 변수에 대한 큐에서 대기하게 되고, 그렇게 대기를 하게되면 최우선 시행되는 프로세스는 **B**가 될것입니다. 이런 형태로 모니터는 실행 순서를 제어합니다.

## 출처

---

[이미지 출처](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)

