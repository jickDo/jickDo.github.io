---
title: 페이징에 대해 알아보기
tags: 운영체제
article_header:
type: cover
---

### 연속 할당의 문제점

---

연속적 할당의 대표적인 문제점은 **외부 단편화**가 있습니다. 외부 단편화란 특정 프로세스를 실행시키기 위해
필요한 공간이 있음에도 빈공간이 연속적이지 않아서 발생하는 문제입니다.

이러한 문제를 해결하기 위해서는 **불연속 할당** 방식 중 대표적인 **페이징**기법을 사용할 수 있습니다.

<br>
<br>

## 페이징이란?

---

![img.png](paging.png)

페이징 기법은 프로세스를 일정한 단위로 자릅니다. 또한 프로세스가 들어갈 메모리 공간 또한 일정한 단위로 자릅니다.

여기서 프로세스를 일정한 단위로 자르면 일정한 **논리 주소 공간**이 생기는데 이것을 **페이지**라고 부르며,
일정한 단위로 잘린 메모리 **물리 주소 공간**은 **프레임**이라고 부르게 됩니다.

여기서 **프레임**, **페이지**의 일정한 단위는 동일한 크기로 자르게 됩니다.

이렇게 만들어진 **페이지**를 **프레임**에 할당하는 가상 메모리 관리 기법을 **페이징**기법이라고 부르게 됩니다.

이렇게 일정한 크기를 정하고 불연속 할당을 수행하면 외부 단편화 문제를 줄일 수 있습니다.

<br>

### 페이징에서 스와핑

![img.png](paging_swaping.png)

페이징에서도 이전과 마찬가지로 **스와핑**이 사용됩니다. 차이가 있다면 기존 연속 할당 방식 스와핑은
프로세스 전체가 스왑영역으로 넘어가지만, **페이징 스와핑**은 사용하지 않는 특정 **페이지**만 스왑아웃
시킬 수 있습니다.

이러한 방식은 이후 **가상메모리** 방식을 사용하는데 핵심이 됩니다.

<br>

## 페이지 테이블

---

불연속 할당 방식에는 실행순서에 대한 문제가 하나 있습니다.
연속적 할당 방식에서는 실행순서를 CPU에게 알려줄 필요가 없습니다. 왜냐하면 실제로 물리 메모리에 연속적으로
프로세스에 대한 정보가 있기 때문에 순서대로 실행시키면 되기 때문입니다.

하지만, **불연속 할당**은 상황이 다릅니다. 메모리상 프로세스에 대한 정보가 연속적이지 않기 떄문에
이를 실행시키는 **CPU**입장에서는 어떤 프로세스를 실행시켜야 할지 알기 어렵습니다.

<br>

![img.png](page_table.png)

<br>

이를 해결하기 위해서 **페이지 테이블**이란것을 사용합니다.

**페이지 테이블**은 **페이지 번호**, **프레임 번호**를 짝지어 줍니다. 그렇게 되면 **CPU**입장에서는
**페이지 번호**만 알고있다면 **페이지 테이블**을 통해 **프레임**으로 접근이 가능하기 때문입니다.

페이지 테이블은 프로세스마다 각자의 페이지 테이블을 가지게 됩니다.

<br>
<br>

## 페이지 테이블 베이스 레지스터(PTBR)

---

페이지 테이블은 프로세스마다 가지고 있고, 이는 **메모리**에 저장됩니다.

하지만, CPU 입장에서는 결국 **페이지 테이블**의 위치를 알아야 합니다. 이러한 기능을 수행하는게
**CPU**내의 존재하는 **PTBR**입니다.

**PTBR**은 **CPU**내에 존재하고 **페이지 테이블**의 위치를 기록합니다.

![img.png](ptbr.png)

해당 그림처럼 특정 프로세스 작업을 수행하기 위해서 **CPU**는 해당 **PTBR**내부 프로세스의 페이지 테이블을
조회합니다. 이후 메모리내부 해당 페이지 테이블 주소로 넘어가서 특정 프로세스의 페이지 까지 접근하게 됩니다.

<br>
<br>

### 비효율적인 접근

---

이전 **페이지 테이블**을 참조하는데 한가지 문제가 있습니다.

**CPU**는 **페이지 테이블**로 접근하고, 해당 값들을 통해 실제 **페이지**로 접근합니다.

즉, 하나의 조회에 대해 두가지 접근을 수행하게 됩니다. 이러한 방식은 비효율적입니다.
그렇기 때문에 **캐싱**기능을 통해 이를 해결하고 이러한 기능을 수행하는게 **TLB**입니다.

<br>

## TLB(Translation Lookaside Buffer)

---

![img.png](tlb.png)

**TLB**는 CPU 곁에 존재하며 이는 페이지 테이블에 대한 **캐시 메모리**입니다.
참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 가져와서 저장합니다.

여타한 캐싱 기능과동일하게 리소스가 **TLB**를 통해서 나오게 되면, **히트**했다. 그것이 아니라면
**미스**했다 라고 표현합니다.


<br>
<br>

## 페이징에서의 주소 변환

---

**특정 주소**에 접근하기 위해서는 두가지 관점의 정보가 필요하게 됩니다.

1. 어떤 페이지 혹은 프레임에 접근하고 싶은지
2. 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있을지

<br>

이중에서 1번은 기존 **페이지 번호**를 통해서 해결할 수 있습니다.
하지만, 2번의 말은 조금 애매하게 들리는데 이를 풀어서 설명하면,
하나의 **주소**내에서도 **논리** 혹은 **물리**주소에 따른 순차적인 주소가 있습니다.

n번지, n+1번지, n+2번지.... 처럼 세부적인 **지점**을 의미합니다.

1번 주소를 통해서 **페이지**혹은 **프레임**에 접근한다면 그 중 명확한 지점을 식별해야 하기 때문에

페이징 시스템에서는 **페이지번호**, **변위**를 이용합니다.

자세한 예시는 아래 그림을 통해서 하겠습니다.

<br>

![img.png](paging_address_trans.png)

페이지, 페이지 테이블, 프레임을 나타내는 그림입니다. 이러한 그림은 특정 페이지에 접근하기 위해
페이지 테이블을 참조하고 프레임 번호를 얻어 실제 메모리 프레임에 접근하는 시퀀스 입니다.

만약 **CPU**가 5번페이지에 변위가 2인 곳에 접근하려고 하면 10번지로 접근하게 될것입니다.

1. 5번 페이지는 1번 프레임에 있다.
2. 1번 프레임의 시작 번지수는 8번지이다
3. 8번지에 변위 2를 더해서 최종주소는 10이 된다.

여기서 주의 할점은, 논리주소의 변위를 최종 물리 주소상 프레임 번지에 더하였다는 것입니다.
> 이말은, 논리주소의 변위 == 물리주소의 변위 입니다.

이것이 가능한 이유는 처음 페이징 방식을 사용할때 페이지와 프레임 변환과정에서 **특정 크기**로 나누게 되고,
그 간격이 같기 때문에 논리주소의 변위랑 물리주소의 변위는 같다는 결론이 나옵니다.

<br>
<br>

## 페이지 테이블 엔트리

---

페이지 테이블 엔트리는 페이지 테이블 **row**를 지칭하는 단위입니다.

![img.png](pte.png)

지금까지는 이러한 페이지 테이블에는 페이지 번호, 프레임 번호만 존재 한다고 설명했습니다.
하지만, 다른 중요한 정보들도 있습니다.

1. 유효 비트
2. 보호 비트
3. 참조 비트
4. 수정 비트

<br>

### 유효 비트

유효비트는 해당 페이지에 접근 가능한지 여부를 알려줍니다. 대표적으로 접근 불가능 한 경우는
**스와핑**으로 인한 해당 **페이지**가 **스왑영역**으로 들어간 경우입니다.

이러한 경 **페이지 폴트**라는 예외가 발생하며, 하드웨어 인터럽트 처럼 처리 됩니다.

1. CPU는 기존 작업 내역을 백업합니다.
2. 페이지 폴트 처리 루틴을 실행합니다.
3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해줍니다.
4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근할 수 있게 됩니다.

<br>

### 보호 비트

보호비트는 페이지 보호 기능을 위해 존재합니다. 리눅스의 읽기 쓰기 권한을 생각하면 됩니다.
해당 페이지가 읽기 전용 페이지라면 보호비트는 0을 나타내고, 읽고 쓰기가 가능하다면 1을 나타냅니다.

<br>

### 참조 비트

**CPU**가 접근한적 있는지 여부를 나타냅니다. 참조된 비트라면 1을 나타내며, 그렇기 않다면 0으로 유지됩니다.

<br>

### 수정 비트

해당 페이지에 데이터를 쓴 적이 있는 여부를 나타냅니다. 수정 여부를 확인해야 하는 이유는 **스와핑** 떄문입니다.
만약 **CPU**가 페이지에 대한 내용을 수정했다면, 스와핑 과정에서 보조 기억장치에 있는 데이터 또한 수정해야 하기 때문입니다.





## 출처

---

[이미지 출처](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)
