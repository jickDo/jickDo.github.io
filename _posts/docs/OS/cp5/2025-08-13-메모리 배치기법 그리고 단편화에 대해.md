---
title: 메모리 배치기법 그리고 단편화에 대해
tags: 운영체제
article_header:
type: cover
---

## 연속 메모리 할당

---

![](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp5/21/sequencial_memory.png)

**연속 메모리 할당**이란 메모리에 프로세스가 그림처럼 **연속적**으로 배치되는 상황을 가정합니다.

프로세스 A가 할당되고, 남는 주소만큼 이어서 B,C,D...를 할당하는 방식입니다.

이런 방식은 예제를 위한 단편적인 설명만 가능한데 이유는 아래에서 설명할 **스와핑**과 관련이 있습니다.

<br>

## 스와핑이란?

---

메모리는 실행시킬 프로세스를 적재하게 됩니다. 하지만, 이런 프로세스들 중에 현재 실행되지 않는 프로세스는 처리해줘야 합니다.
메모리 리소스가 한정적이기 때문입니다.

여기서 말하는 실행되지 않는 프로세스의 예시는 **I/O**작업, 오랫동안 사용되지 않는 프로세스가 이에 해당합니다.

<br>

![](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp5/21/swaping.png)


<br>

그렇다면 이러한 프로세스를 메모리에서 처리하는 방법이 필요한데 그 방법이 **스와핑** 입니다.

**스와핑**은, 두가지 행위를 통해서 수행할 수 있습니다.

> 스왑 아웃: 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것 (메모리 -> 스왑 영역)

> 스왑 인: 스왑영역에 있던 프로세스가 다시 메모리로 옮겨지는 것 (스왑 영역 -> 메모리)

또한 메모리에서 보조기억장치로 옮겨질때 **스왑영역**으로 프로세스를 옮겨두는데 그 영역을 **스왑 영역**이라고 합니다.

<br>
<br>

## 메모리 할당 방식

---

프로세스는 메모리 속 비어있는 공간에 적재되어야 합니다. 비어 있는 메모리 공간에 프로세스를 연속적으로 할당하기 위해
**세가지** 방법을 고려할 수 있습니다.

1. **최초 적합(first fit)**
2. **최적 적합(best fit)**
3. **최악 적합(worst fit)**

각방식을 아래 예시를 통해 들어보려 합니다.

프로세스 A,B,C는 이미 적재되어있고, 빈 공간 A,B,C가 있습니다. 앞으로 적재할 프로세스는 20MB크기를 가지고 있으며
적재 방식에 따라 이를 어디에 적재할지 달라지게 됩니다.

![](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp5/21/memory_stacking.png)


<br>

## 최초 적합

---

최초 적합은 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식입니다.
이전 그림에서 운영체제가 빈공간 A,B,C 순서대로 검색을 하였다면 가장 먼저 검색된 A 빈공간에 적재되는 방식입니다.

![](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp5/21/first_fit.png)


적재후 모습은 그림과 같으며 해당 방식은 검색을 최소화 하며 **빠른 할당**을 가능하게 하는 장점이 있습니다.
하지만, 이후에 보게 될 **외부 단편화**가 생길 가능성이 높아지게 됩니다.

<br>
<br>

## 최적 적합

---

최적 적합은 운영체제가 빈공간을 **모두** 검색한 후 프로세스가 적재될 수 있는 공간 중 가장 **작은 공간**에 프로세스를
배치하는 방식입니다.
이전 그림에서는 빈 공간 C가 가장 적합한 크기를 가진 공간이기 때문에 그곳에 적재 됩니다.

![](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp5/21/best_fit.png)


적재후 모습은 그림과 같으며 해당 방식은 적재할 프로세스 크기를 고려한 방식이기 때문에 **외부 단편화**를
최소화 할 수 있다는 장점이 있지만, **모든**공간을 검색하는 행위가 **오버헤드**를 발생시키기 때문에 느려집니다.

<br>
<br>

## 최악 적합

---

최악 적합은 운영체제가 빈 공간을 모두 검색한 후, 가장 큰 공간에 프로세스를 적재하는 방식입니다.

![](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp5/21/worst_fit.png)


적재 후 모습은 가장 빈공간의 크기가 큰 B에 적재되는 것을 확인할 수 있습니다. 이러한 방식은
외부 단편화의 발생 빈도도 크며, 모든 공간을 검색한다는 비효율적인 측면도 가지고 있습니다.

<br>

지금까지 **외부 단편화**라는 용어가 단점으로 설명했습니다.
그렇다면, **외부 단편화**는 어떠한 문제일까요?

<br>

## 단편화

---

단편화는 크게 두가지로 나눌 수 있습니다.

1. 내부 단편화
2. 외부 단편화

<br>

### 내부 단편화

![](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp5/21/first_fit.png)


내부 단편화 문제는 이전 **최초 적합** 사례에서 볼 수 있습니다.
빈공간A의 크기는 30MB인데 적재한 프로세스는 20MB입니다. 이런경우 10MB의 빈공간이 생기게 되고 이러한 비어있는
공간을 **내부 단편화**가 발생했다고 표현합니다.

<br>

### 외부 단편화

![](https://raw.githubusercontent.com/jickDo/picture/master/OS/study/cp5/21/first_fit.png)


외부 단편화 문제는 이전 **최초 적합** 사례를 이어서 설명하겠습니다.
현재 그림속 비어있는 공간은 **80MB**입니다. 하지만 해당 공간에 **80MB**크기의 프로세스를 적재할 수 없습니다.
이유는, 빈 공간이 연속적인것이 아닌 프로세스C에 의해 끊어져있기 때문입니다.

이처럼, 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상을 지칭합니다.

이러한 외부 단편화를 해결할 수 있는 대표적인 방안은 메모리를 **압축**하는 방법이 있습니다.

<br>

## 압축

---

**압축**이란 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 메모리 내에 저장된 프로세스를 재배치 시켜 빈 공간을
하나의 큰 빈 공간으로 만드는 방법입니다.

이러한 방식은 단점이 있는데, 메모리의 빈공간을 모으는 작업은 시스템을 중지 시킨다는 문제가 있습니다.
또한, 메모리를 옮기는 작업이 큰 오버헤드를 만들고, 최적화 방법에 대한 정답을 고르기가 어렵습니다.








## 출처

---

[이미지 출처](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)







