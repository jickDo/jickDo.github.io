---
title: Jpa가 영속성을 관리하는 법
tags: Jpa
article_header:
type: cover
---

# 엔티티 매니저와 엔티티 매니터 팩토리의 차이

---

**엔티티 매니저 팩토리**는 **엔티티 매니저**를 생상하는 공자과 같다. 일반적으로 데이터 베이스를 하나만 사용하는
환경에서는 **엔티티 매니저 팩토리**를 하나만 생성하게 된다. 하나만 생성하는 이유는 팩토리를 만드는 비용이 크다.
가령 **커넥션 풀**을 이때 생성한다. 반면 **엔티티 매니저**는 생성 비용이 작다. 이러한 차이로 **엔티티 매니저 팩토리**는
에플리케이션이 공유해서 사용하며 그렇기 때문에 스레드간 동시접근하여도 안전하게 설계되어있다. 반면에 **엔티티 매니저**는 스레드 간
공유시 동시성 문제가 발생할 수 있다.

<br>
<br>

# 영속성 컨텍스트란 무엇일까?

---

**Jpa**의 핵심과도 같은 단어인 **영속성 컨텍스트**를 설명하려 한다. 우리말로 직역하면 **데이터를 영구 저장하는 환경**이다.

데이터를 저장하거나 조회하게 되면 이 **영속성 컨텍스트**의 엔티티를 저장하게 된다.

````java
em.persist(entity);
````

로 값을 저장할 수 있다.

**영속성 컨텍스트**란 말 자체가 논리적인 내용에 가깝기 떄문에 실제로 보기 보다는, 엔티티 매니저를 생성할 때, 하나가 만들어진다고 생각 하면 된다.

> 여러 엔티티 메니터가 **영속성 컨텍스트**에 접근 할 수 있지만, 이는 이후에 배울 부분에서 설명하겠다.

<br>
<br>

## 엔티티의 생명주기

---

**영속성 컨텍스트**가 엔티티를 어떻게 다루고 있는지에 따라 **엔티티**의 생명주기가 4가지로 나뉜다.

<br>
<br>

### **비영속**

이는 영속성 컨텍스트와 관련없는 **persist** 가 되기전 상태의 순수한 엔티티이다.

코드로 이를 보게 되면

````java
Member member = new Member();
member.setId("member1");
member.setUsername("임직찬");
````

위 코드처럼 엔티티를 생성하고 값을 담았지만, 어딘가에 저장한 즉 **persist**하지 못한 순수한 엔티티를 **비영속**상태라고 한다.

<br>
<br>

### **영속**

엔티티가 **엔티티 매니저**를 통해 **persist** 된 상태 다르게 말하면 **영속성 컨텍스트**가 **엔티티**를 관리하는 상태를 **영속**상태라고 한다.

<br>
<br>

### **준영속**

영속 컨텍스트가 관리하던 엔티티를 더 이상 관리하지 않는 상태가 되면 이를 **준영속**상태가 되었다고 한다. 이후에도 다루겠지만

````java
em.detach(member);
em.clear(member);
em.close(member);
````

위 세가지 구문으로 가능하다.

<br>
<br>

### **삭제**

엔티티를 **영속 컨텍스트**와 **데이터베이스**에서 삭제한 상태를 말하게 된다

````java
em.remove(member);
````

<br>
<br>

# 영속성 컨텍스트의 특징

---

## 1. 영속성 컨텍스트와 식별자

영속성 컨텍스트는 엔티티를 **식별자** 값으로 구분한다. 여기서 말하는 **식별자**란 **@id**이다.

<br>
<br>

## 2. 영속성 컨텍스트와 데이터베이스 저장

영속성 컨텍스트에 쌓인 변경사항은 **쓰기 지연 저장소**에 저장되고, 이는 트랜잭션 커밋 시점에 데이터베이스에 반영된다.
이를 **flush**라고 한다.

<br>
<br>

## 3. 영속성 컨텍스트를 쓰는 이유

영속성 컨텍스트를 쓰는 이유가 뭘까? 아래와 같은 장점이 있다.

1. 1차캐시
2. 동일성 보장
3. 트랜잭션을 지원하는 쓰기 지연
4. 변경 감지
5. 지연 로딩

<br>
<br>

### 1. 엔티티 조회

엔티티 조회에서 위 장점중 **1번** 그리고 **2번** 장점을 설명할 수 있다.

**영속성 컨텍스트**는 내부에 캐시를 가지고 있는데, 이것을 **1차 캐시**라고 한다.

````java
Member member = new Member();
member.setId("member1");
member.setUsername("임직찬");

em.persist() //영속화
````

위 과정을 통해 조회에서 사용할 엔티티를 하나 등록한다.

````java
em.find("member1");
````

을 통해 **엔티티 매니저**에게 조회를 요청할 수 있다.
조회가 요청되면 **엔티티 매니저**는 요청받은 키값을 기반으로 **1차 캐시**에 같은 식별자를 검색한다.
만약 **1차 캐시**에서 값을 조회하지 못했다면, 데이터베이스로 접근해 조회를 수행하고, 조회한 값으로
엔티티를 생성한 후 이를 **1차 캐시**에 등록하고 값을 반환한다.

여기까지 **1차 캐시**라는 내용을 알아 볼 수 있었는데, 그럼 어떻게 조회로 **동일성**을 보장할 수 있을까?

그 이유는 바로 **1차 캐시**이다. **1차 캐시**는 **@Id**라는 **식별자**를 가지고 엔티티를 구분짓는 다고 했다.
즉 같은 **@Id**가 들어오게 되면 이를 통해 **1차 캐시**에 저장된 같은 엔티티를 조회하기 떄문이다.

<br>
<br>

### 2. 엔티티 등록

**엔티티 등록**에서는 **3번** 과정의 장점을 설명할 수 있다.

````java
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();

transaction.begin(); //트랜잭션 시작

em.persist(memberA);
em.persist(memberB);
//여기까지 쓰기 지연저장소 저장

transaction.commit();
````

위 코드처럼 **엔티티 매니저**는 트랜잭션 시작후 쌓인 **Insert Sql**을 데이터베이스에 전송하지 않고, 트랜잭션이 종료되는 순간
이를 한번에 전송하게 된다.

위 코드처럼 진행하게 되면 **memberA**를 **persist**하는 순간 1차 캐시에 **memberA**의 정보가 등록됨과 동시에
**쓰기 지연 저장소**에 **memberA**의 **Insert Sql**이 등록 될것이다. 마찬가지로 **memberB**도 같은 방식을 취한다음에,
트랜잭션이 종료되면 트랜잭션이 **commit**이 되면서 **엔티티 매니저**가 **flush**하게 될것이고, **flush**는 영속성 컨텍스트의 정보를 데이터베이스로
동기화 하는 과정이다.

<br>
<br>

### 어떻게 쓰기 지연이 가능한가?

데이터 베이스 입장에서 실제 **commit**전까지 데이터를 등록하여도 실제로 데이터가 등록이 되는것은 아니다.
결국 **commit**전까지 데이터를 쌓아두고 있다가 일괄처리 하는 개념인데, 그렇기 때문에 이를 어플리케이션 단에서
데이터를 모아두고 실제 **commit**시점에 일괄처리 하는게 가능하다.

<br>
<br>

### 3. 엔티티 수정

**엔티티 수정**에서는 **4번**의 장점을 설명할 수 있다.

````java
Member memberA = em.find(Member.class, "memberA");

memberA.setUsername("변경된 이름");

transaction.commit();
````
이 구문은 실제로 **update**라는 기능이 없음에도 작동한다. 이유는 **변경감지**에서 나온다.

**Jpa**는 영속성 컨텍스의 **1차 캐시**에 값을 저장할 때 **스냅샷**이라는 초기 모습을 저장한다.

이후, 트랜잭션을 커밋하는 순간 **엔티티 매니저**는 **flush**를 호출하고 데이터 베이스와 **영속성 컨텍스트**를 동기화 하려고 한다.

그 전에 **1차 캐시 스냅샷**과 엔티티를 비교 후 값이 달라졌다면 **Update Query**를 쓰기 지연 저장소에 담고, 이과정을 반복한다.

이후 실제 값이 동기화 되는 시전에 **쓰기 지연 저장소**에 수정된 값이 담겼을 것이기 때문에 이를 같이 **Commit**한다.

<br>
<br>

### 실제 업데이트 쿼리는 어떻게 나갈까?

위 처럼 이름만 변경된 경우 업데이트 쿼리에 **SET NAME = '변경된내용'** 이렇게 유추 할 수 있다.
하지만, **Jpa**는 모든 구문을 업데이트 한다.

이유는 수정되는 쿼리가 항상 같기 때문에 어플리케이션 로딩 시점에 수정쿼리를 생성 후 재사용할 수 있다.
추가적으로, 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 파싱된 쿼리를 재사용할 수 있다.

<br>
<br>

### 4. 엔티티 삭제

엔티티를 삭제하려면 먼저 삭제 대상 엔티티를 조회해야 한다. 조회 후

````java
em.remove(memberA);
````
를 통해 대상 엔티티를 삭제하면, 쓰기 지연 저장소에 삭제에 대한 쿼리가 담기게 된다. 그리고 영속성 컨텍스트에서도 같이 제거된다.

<br>
<br>

# 플러시(Flush)

---

플러시를 실행하면 두가지 일이 발생한다.

1. 변경 감지가 실행된다.
2. 영속성 컨텍스트와 실제 데이터베이스와 정보를 동기화한다.(쓰기지연 저장소 내용을 디비로 보낸다).

<br>

이를 호출하는 방법은 크게 세가지가 있는데

1. em.flush()
2. 트랜잭션 커밋 시 자동 호출
3. JPQL구문이 실행시 자동으로 호출

<br>
<br>
<br>
<br>

## 준영속이란

지금 까지는 영속에 관련한 정보만 다루었는데 이번에는 **준영속**에 대해서 설명하겠다.

1. em.detach(entity) //영속성 컨텍스트 준영속
2. em.clear() //영속성 컨텍스트 초기화
3. em.close() //영속성 컨텍스트 종료

위 세가지 방식으로 **준 영속**상태가 가능하다.

1번방식은 해당하는 엔티티만 **준영속**상태로 만든다. 즉, 나머지 **영속성 컨텍스트**는 유지된다.

2번방식은 영속성 컨텍스트 전부 제거하는 방식이다. 3번방식은 영속성 컨텍스트 자체를 종료하는 방식으로
2번과의 차이는 칠판에 내용을 전부 지우는 것과, 칠판을 없애는 것의 차이정도가 있다.

<br>
<br>

## 준영속 상태의 특징

1. 거의 비영속 상태에 가깝다.

> 영속성 컨텍스트가 관리하지 않기 때문에, 1차 캐싱 및 쓰기 지연저장소, 지연로딩을 사용할 수 없다.

2. 식별자 값은 가지고 있다.
> 이미 한번 영속 상태였기 때문에 무조건 식별자가 존재한다. 비영속은 식별자를 아직등록 안했다면 없을 수 있다.

3. 지연 로딩 할 수 없다.
> 이는 이후에 배울 내용에 자세하게 나와서 거기서 다시 설명하겠다.

<br>
<br>
<br>

# 병합

준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 **병합**을 사용해야 한다.

이 과정을 설명하면

<br>

1. merge()를 시행한다.
2. 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회한다.
2-1. 1차 캐시에 없다면 이전과 같이 디비에서 조회한다.
3. 조회한 영속 엔티티에 조회된 값을 채워넣는다.
4. 이제 값이 채워진 엔티티를 리턴한다.

이 과정에서 파라미터로 넘기는 엔티티와 새롭게 조회된 값으로 담긴 엔티티는 다른 엔티티가 되는데, 이유는 파라미터의
엔티티는 계속 **준영속** 상태이지만, 결과값의 엔티티는 **영속**상태이기 때문이다.

그렇기 떄문에
````java
member = em.merge(member);
````
로 변경해야 한다.

<br>

### 특이사항

병합은 **준영속**, **비영속**을 가리지 않기 때문에 **비영속**을 **merge**한 경우 새로 생성해서 병합한다.

## 결론

---

1. 엔티티 매니저가 있고, 엔티티 매니저 팩토리가 있다. 매니저 내부에는 영속성 컨텍스트가 있다.
2. 영속성 컨텍스트는 데이터베이스 사이에서 객체를 보관하는 가상의 데이터 베이스 역할을 한다.
3. 일반적으로 트랜잭션을 커밋할때 영속성 컨텍스트가 플러시된다.

<br><br><br>
