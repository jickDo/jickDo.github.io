---
title: 프록시와 연관관계 관리
tags: Jpa
article_header:
type: cover
---

# 프록시

---

상품과 주문내용이 있는 테이블이 있다고 가정한다. 하나의 상품에 해당하는 주문의 n건일것이다. 그렇기 떄문에 이를 일대다 관계라고 할 수 있다.

이를 연관 매핑을 수행 후 조인을 하게 되면 이론상 상품을 주문할때마다 그에 해당하는 주문이 매번 조회 될것이다.

이런 방식의 문제점은 그저 상품리스트를 보여주는 화면이라면 연관된 주문까지 쿼리에 실려 같이 조회되는 문제가 있을것이고, 그렇게 된다면 조회 성능이 상당히 떨어질것이다.

이를 **Jpa**는 지연로딩을 통해 풀어낸다. 여기서 사용하는 기술이 **프록시**이다.

**지연 로딩이란** 실제 데이터를 사용하는 시점까지 조회를 미루고 이를 실제 사용할때 접근해 조회하는 기술이다.

<br>
<br>

## 프록시 기초

---

지금까지 하나의 엔티티를 조회할때는 **em.find()** 를 통해서 값을 조회했다. 지금부터는 실제 사용하는 시점까지 조회를 미루기 위해
**em.getReference()** 를 사용할것이다. 이를 호출하면 실제 데이터베이스를 조회하지 않고, 실제 엔티티를 생성하지도 않는다. 그저
프록시 객체를 반환한다.

<br>
<br>

### 프록시 특징

---

프록시는 실제 객체를 상속받아 진짜 객체처럼 보이는 가짜 객체를 말한다. 이런 **프록시 객체**는 실제 **객체**로 접근하는 주소값을 보관하고 있다.

이런 **프록시 객체**는 실제 엔티티에 접근하는, 그니까 예를들어 **member.getName()**처럼 실제 사용될 떄 실제 엔티티 객체를 생성하게 되는데, 이를 **프록시 객체 초기화**라고 부른다.

<br>

프록시 객체의 초기화 과정은 아래와 같다.

<br>

1. 프록시 객체에 실제 메소드를 이용해서 데이터에 조회가 들어온다.
2. 실제 엔티티가 없다면 영속성 컨텍스트에 실제 엔티티 생성을 요청하고, 이를 **프록시 초기화**라고 한다.
3. 영속성 컨텍스트는 실제 데이터베이스에 조회를 수행 한 후 실제 엔티티 객체를 생성한다.
4. 프록시 객체는 생성된 엔티티 객체의 참조를 보관하게 된다.
5. 프록시 객체는 실제 엔티티 객체로 함수를 호출해서 결과를 얻는다.

<br>
<br>

위 과정에서 알 수 있는 프록시의 특징은 아래와 같은데

<br>

1. 프록시 객체는 처음 사용할 때 한 번만 초기화 된다.
2. 프록시 객체의 초기화가 실제 엔티티로 변경하는 과정이아니라, **프록시 초기화 되었다는것은** 실제 엔티티로 접근할 수 있음을 말한다.
3. 만약 **em.getReference()**를 호출했을때 1차캐시에 값이 있다면 그 값을 바로 리턴한다. 이경우에는 프록시를 쓸 이유가 없기 떄문이다.

<br>
<br>

### 프록시 확인하는법

---

**Jpa**가 제공하는 **PersistenceUnitUtil.isLoaded(Object entity)** 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있다.

이경우, 이미 초기화되었거나, 프록시 인스턴스가 아닐경우 true를 반환한다.

조회된 엔티티가 **프록시**인지 확인하려면 클래스명을 직접 호출해서 (javassist)가 있다면 프록시라고 생각하면 된다.

<br>
<br>

## 즉시 로딩과 지연로딩

---

프록시 객체의 주 사용처는 지연로딩이라고 할 수 있는데, **지연 로딩**이란 실제 값이 사용될때, 그니까 상품을 조회했는데 그과정에서 그안에 일대다 관계로 있는 **주문** 내용이
같이 조회될지 아니면 실제 주문 내용을 가져와야 할떄 조회될지 정하는 기능이다.

<br>
<br>

### 즉시 로딩이란

---

**ManyToOne**의 fetch속성을 **FetchType.EAGER**로 설정하면 되고 , 이를 어플리케이션 코드로 본다면

````java
Member member = em.find(Member.class, "member1")
Team team = member.getTeam();
````

<br>

이런 형태의 코드가 될것이다. 즉시 로딩은 연관된 매핑에 따라 **n**번의 쿼리가 나가기 떄문에 이를 조인으로 풀어낸다.

<br>

```` sql
SELECT MEMBER.*, TEAM.*
FROM Member AS MEMBER
  JOIN Team AS TEAM
  ON TEAM.id = MEMBER.id
WHERE MEMBER.id = 'member1'
````

이런 쿼리 구문이 될것이다. 여기서 주의 할것은

<br>

예제 구문에서 그냥 JOIN이라고 썻는데, 만약에 외래키가 **NULL**을 허용한다면 **OUTER JOIN**, 그렇지 않다면 **INNER JOIN**로 조회 할것이다.
**OUTER JOIN**보다  **INNER JOIN**이 성능상 이점이 있기 떄문에 만약에 멤버가 무조건 팀에 속하는게 확실하다면 외래키를 **NOT NULL**로 만들자

<br>
<br>

### 지연 로딩이란

---

지연로딩을 사용하기 위해 **ManyToOne(FetchType.LAZY)** 을 사용해야 한다. 앞서 **지연 로딩**에 대한 서론을 마쳤다고 생각하기 때문에 기본적인 것을 생략하겠다.

<br>
<br>

## 기본 JPA 페치 전략

---

쉽게 생각해서 엔티티가 하나면? **즉시로딩**, 엔티티가 컬렉션이면 **지연로딩**이다.

엔티티가 컬렉션이란건 **n**개 즉 복수개를 의미하는 것이고, 이를 연관관계 어노테이션으로 보면 **MANY**가 뒤에 붙어있는것이다. **OneToMany**, **ManyToMany**

하지만 추천하는 방법은 모든 관계를 **지연로딩**으로 설정하고 그곳에서 발생하는 문제를 이후에 대응하는 것이다. **지연로딩**이 필요하다고 생각되는 부분에서 이후 바꾸는것이 좋다.

<br>
<br>

## 영속성 전이:CASCADE

---

**영속성 전이**란 **부모 엔티티**의 **영속성** 특징을 자식에게 어떻게 맞출지 결정하는 부분이다.

만약 부모 엔티티를 저장하는데 자식 엔티티도 저장하는 로직이라면 두곳의 영속을 관리해야 하지만, 영속성관리 설정을 켜두면

부모 엔티티를 설정하는 것만으로도 자식 엔티티의 연관을 설정할 수 있다.

**CASCADE** 종류는

1. ALL - 모두적용
2. PERSIST - 영속
3. MERGE - 병합
4. REMOVE - 삭제
5. REFRESH - REFRESH
6. DETACH - DETACH

이런 설정들이 있고, 보통은 ALL을 많이 사용한다.

<br>
<br>

## 고아객체

---

만약 부모 객체를 삭제한다면 자식 객체는 어떻게 될까? 당연히 유령 데이터가 될것인데, 이를 **고아 객체**라고 부른다.

하지만 이를 영속성 전이를 통해서 부모를 삭제하면 자식도 삭제되게 한번에 관리가 가능하다.

이는,

<br>

**@OneToMany(~~ , orphanRemoval = true)**

이렇게 설정할 수 있다. 이렇게 되면 부모 엔티티르 삭제시 자식까지 같이 삭제가 된다.

이전에 배웠던 내용대로 **CasCadeType.ALL + orphanRemoval = true**로 설정시 부모 자식간의 발생할 수 있는

영속성 문제를 쉽게 다룰수 있다.

## 결론

---

1. **Jpa**에는 프록시 객체를 생성할 수 있고, 실제 조회시점까지 엔티티 조회를 미루는 기능이다.
2. 이를 활용해서 지연 로딩을 할 수 있다.
3. 더불어, 영속성 전이와 고아객체 삭제 설정을 통해 부모 자식 엔티티 관리를 한번에 수행할 수 있다.

<br><br><br>






