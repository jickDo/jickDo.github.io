---
title: Jpa 고급매핑
tags: Jpa
article_header:
type: cover
---

# Jpa에서 다뤄지는 고급매핑

---

**Jpa**는 일반적인 매핑방식을 제외한 특이한 방식을 제공하는데 오늘은 그것을 다뤄보려고 한다.

<br>

1. 상속 관계 매핑
2. **MappedSuperclass**
3. 복합 키와 식별 관계 매핑
4. 조인 테이블
5. 엔티티 하나에 여러 테이블 매핑하기

<br>
<br>

## 상속 관계 매핑

---

**Jpa**는 데이터베이스 데이터를 **객체**관점 어플리케이션에서 다룰 수 있게 해주는 일종의 **Mapper**이다.

그렇다 보니 **데이터베이스** 관점에서 존재하지 않던 **상속**이런 개념을 어떻게 매핑할지 에 대한 대비를 해야한다.

**슈퍼타입 서브타입**이라는 비슷한 개념이 존재하기 떄문에 이 방법을 이용해서 풀어낸다.

**슈퍼타입 모델을**을 **물리 모델 테이블**로 변환하는 방법에는 3가지가 존재하는데,

<br>

1. 각각을 테이블로 변환
2. 통합 테이블로 변환(단일 테이블)
3. 서브타입 테이블로 변환

<br>
<br>

### 1. 조인 전략

---

우선 각각을 테이블로 변환하는 방식으로, 부모타입을 구현하고 자식은 부모의 **기본키**와 자신의 **기본키**를 이용해서 **(기본키+외래키)** 를 이용해서 **조인**을 활용하는 방식이다.
이 방식은 **데이터 베이스**입장에서 어떤 서브타입에 자식인지 구분하기 위해 구분자인 **컬럼을 추가해야 한다**.

<br>
<br>

````java
@Entity
@Inheritance(stragegy = InheritanceType.JOINED)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {

	@Id
	@GeneratedValue
	@Column(name = "ITEM_ID")
	private Long id;

	private String name;
	private int price;
  ...
}

@Entity
@DiscriminatorValue(name = "A")
public class Album extends Item {
	private String artist;

  ...
}

@Entity
@DiscriminatorValue(name = "M")
public class Movie extends Item {
  private String director;
  private String actor;

  ...
}
````

<br>
<br>

**상속 매핑**은 부모 클래스에 **@Inheritance** 을 구현해야 하고, 조인 전략을 사용중이기 떄문에 **JOINED**으로 지정한다.

그리고 **부모 클래스**에 **DiscriminatorColumn**을 지정해서 자식 테이블을 어떻게 구분할지 컬럼을 명시하고,

마지막으로 자식에도 **@DiscriminatorValue(name = "")** 을 넣어서 구분자의 이름을 명시해야 한다.

<br>
<br>

주의점은 **자식 클래스** **ID**는 부모 클래스 이름 그대로 사용하기 떄문에 **PrimaryyKeyJoinColumn**을 통해 재정의를 하는것이 좋다.

이 방식의 장점은,

<br>

1. 테이블을 정규화 할 수 있다.
2. 저장공간을 효율적으로 사용할 수 있다.

<br>
<br>

이 방식의 단점은,

<br>

1. 조회시 조인이 일어나기 때문에 성능이 저하될 수 있다.
2. 조회 쿼리가 복잡하다.
3. 데이터를 등록할때 자식까지 포함하여 **Insert Sql**이 두번시행된다.

<br>

이런 단점이 있다. 전형적인 **서브타입**, **슈퍼타입**을 구분해서 모두 구현하는 방식이고, 그렇기 때문에 정규화라는 유리한 점을 통해
확장성을 노릴 수 있지만, 당연히 **성능**이 떨어진다.

<br>
<br>

### 2. 단일 테이블 전략

---

단일 테이블 전략은 이전 **슈퍼타입** 부모 클래스에 **자식**의 필드값을 모두 지정하는 방식이다.

<br>
<br>

````java
@Entity
@Inheritance(stragegy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {
}
... // 이전 내용과 돌일
````

<br>
<br>

이런 방식의 장점은,

1. 조인이 없기 때문에 조회성능이 빠르다(역정규화)
2. 조회 쿼리가 단순하다.

<br>
<br>

단점은,

1. 자식은 모두 null허용해야 한다. (자식은 하나만 사용되기 때문에 결국 나머지 필드는 null이 들어온다)
2. 역졍규화 특성상 오히려 비대해짐에 따라 성능이 떨어질 수 있다.

<br>
<br>

### 3. 구현 클래스마다 테이블 전략

---

이 방법은 기존 **슈퍼 타입**을 제거하고 그 필드의 정보를 모두 **자식** 클래스에 넣는것이다.

이 방식또한 여러 테이블을 조회하게 되면 **UNION**을 사용하며 성능이 떨어진다.

앞서 설명한 내용을 포함해 이번 방식또한 추천하지 않는데 이유는, 이를 개선한 공통 필드만 뽑아서 상속시킬수 있기 떄문이다.

<br>
<br>

## **@MappedSuperclass**

---

이전 방식들은 부모, 자식 테이블을 모두 **매핑**하려고 하였다. 하지만 **@MappedSuperclass**는
부모의 공통 필드만 **자식**클래스에게 제공하고 **부모 클래스**는 **테이블**로 생성하지 않고, 이를 자식클래스에서
상속을 통해 **필드 데이터만 전달**하는 방식이다.

<br>
<br>

````java
@MappedSuperclass
public abstract class BaseTimeEntity {

    @CreatedDate
    private Instant createdAt;

    @LastModifiedDate
    private Instant updatedAt;
}
````

이 전에 사용했던 코드를 가져왔는데, **생성, 수정 시각**은 테이블 관점에서 자주 등장하는 내용이다.

이런 공통된 데이터를 따로 뽑아서 이를 사용하는 엔티티에 상속시키기만 해도 위 필드를 포함한 데이터가

**자식 클래스**에 포함되어 생성된다.

직접적인 엔티티 관리를 안받은 클래스기 때문에 **추상클래스**로 만들기를 권장한다.

<br>
<br>

## 복합 키와 식별 관계 매핑

---

복합키를 만드는 두가지 방식이 있는데, 첫번째는 **식별 관계**, 두번째는 **비 식별 관계**이다.

**식별 관계는** 부모테이블의 **PK**를 외래키로 자신의 **PK**를 엮어 **(기본키 + 외래키)**로 사용하는 방식이고,

**비 식별 관계는** **부모 테이블** 외래키를 **외래키**로만 사용하고 자신의 **PK**로 사용하는 방식이다.

<br>

**비식별**은 외래키가 **기본키**에 포함되지 않기 때문에 **NULL**이 올수도 있는데, 이에 따라

**NULL**을 허용하면 **선택적 비식별**, 그렇지 않다면 **필수적 비식별**이라고 부른다.

<br>
<br>

### 복합키: 비식별 관계

---

우선 비식별 관계를 매핑하는 어노테이션은 두가지이다.

**IdClass**와 **EmbeddedId**이다.

전자는 **데이터베이스**에 맞춰진 방법이고, 후자는 **객체지향**에 맞춰진 방식이다.

<br>
<br>

## 결론

---

1. **Jpa**에는 고급매핑 기술이 여러가지가 있다.

<br><br><br>

이번 장은 경험을 많이 해보지 못하였거나, 이런것이 있다~ 라는 느낌을 받는 내용들이 많았고, 더 탐구하고자 하는 내용을 찾지못하여
학습한 내용을 기계적으로 적을것 같아 멈춰두었습니다.


