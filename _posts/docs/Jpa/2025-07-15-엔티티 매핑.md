---
title: Jpa에서 엔티티를 매핑하는 법
tags: Jpa
article_header:
type: cover
---

# Jpa에서 엔티티 매핑하기

---

여기서 말하는 **엔티티 매핑**이란 어플리케이션의 **엔티티**정보를 데이터 베이스 **테이블**과 매핑하는 것을 말한다.

각각,

1. **객체와 테이블** 매핑을 담당하는 **@Entity, @Table
2. **기본키** 매핑을 담당하는 **@Id**
3. **필드와 컬럼** 매핑을 담당하는 **@Column**이 있다.

<br>
<br>

## **객체와 테이블** 매핑

---

<br>
<br>

### @Entity

**Jpa**에서 테이블과 매핑할 클래스는 **@Entity**를 붙이게 되고, 이를 **Jpa**에서 관리한다.

**name** 키워드를 붙일 수 있으며, 이 **name**은 다른 패키지에서 중복되면 안되고 고유해야 한다.

만약 지정하지 않는다면 클래스명 그대로 사용한다.

<br>
<br>

**@Entity**에서 몇가지 주의 사항이 있는데,

<br>

1. 기본 생성자가 필수다.
2. **final** 클랫스, enum, interface, inner 클래스 사용을 할 수 없다.
3. 저장할 필드에 **final**을 사용하면 안 된다.

<br>
<br>

### @Table

**@Table** 은 엔티티와 매핑할 테이블을 지정한다. 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용하게 된다.

<br>
<br>

### @Column

**@Column**은 실제 컬럼을 지정하는 기능을 한다. **name**같은 이름 지정도 가능하고,

````java
@Column(name = "Name", nullable = false, length=10)
````

이런 값들이 지정 가능하다. 기본 허용값이 null 인것을 주의하면 된다.

<br>
<br>

### @Id

**@Id**는 기본키를 매핑하는 방식이다.

**데이터 베이스**마다 기본키를 자동 할당하는 방식이 다르기 떄문에 기본키 처리 구문이 몇가지 존재한다.

<br>
<br>

1. IDENTITY - 기본키 생성을 데이터 베이스에 위임한다.
2. SEQUENCE - 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다.
3. TABLE - 키 생성 테이블을 사용한다.

<br>
<br>

## IDENTITY

<br>

이 전략은 데이터베이스에 키 생성을 대신 위임하는 전략이다.

````java
@GeneratedValue(strategy = GenerationType.IDENTITY)
````

이렇게 쓸 수 있다. 하지만 **IDENTITY**의 문제는 **em.persist()** 를 할때 생긴다.
왜냐하면 **em.persist()** 는 영속성 컨텍스트에 엔티티를 등록하게 되고 영속성 컨텍스트는 **@Id**라는 식별자로
엔티티를 구분하는데 **Identity**전략 자체가 실제 데이터베이스에 값이 등록될때 **Id**값이 생기기 때문에,
이를 해결하기 위해 **em.persist()** 를 호출하는 순간, 실제 **DB**에 **Insert**를 수행하고 나온 **ID**를
받아오게 되는데, 이 과정을 다르게 말하면 **쓰기 지연 저장소**가 동작하지 않는다는 말이다.

즉, 입력하는 엔티티가 많아질 수록 비효율적인 전략이 될 수 있다.

<br>
<br>

## SEQUENCE

<br>

이 전략은 데이터베이스에서 유일한 값을 순서대로 생성하는 케이스이다.

<br>
<br>

## 테이블 전략

<br>

이는 키 생성 전용 테이블을 하나 만들고 여기에 이름과 값으로 컬럼을 만들어 **시퀀스**를 어플리케이션 단에서 구현 하는 방식이다.

````sql
create table MY_SEQUENCES (
    sequence_name VARCHAR(255) not null,
    next_val BIGINT,
    primary key ( sequence_name)
)
````

이렇게 구현할 수 있고, **SEQUENCE** 방식과 비슷하다.

## 스키마 자동 생성

---

**Jpa**는 스키마 자동 생성하는 기능을 제공한다. 클래스의 매핑정보를 토대로 실제 어플리케이션 로딩중에
이 정보를 이용해서 스키마를 생성할지 말지를 정할 수 있는 옵션이다.

<br>
<br>

5가지가 있는데,

<br>

1. create

이는 **DROP + CREATE** 이다. 실제 어플리케이션이 로딩될떄 기존의 스키마 정보를 모두 드랍하고 이를 초기상태로
재생성 한다.

경험상, 변경이 잦은 초기에는 유용하지만 **ALL DROP**자체가 위험한 기능이기 떄문에 크게 쓸일이 없었던것 같다.

<br>
<br>

2. create-drop

기존 create 기능에 종료시 생성한 **DDL**을 제거하는 기능이 추가되었다. 이도 자주 쓰이는 기능은 아니다.

<br>
<br>

3. update

데이터 베이스 테이블과 엔티티 매핑정보를 비교해서 변경사항만 수정한다.
이는 운영환경 정도에서 쓰일수 있지만 경험상 아래 나오는 **validate**가 더유용하다.

<br>
<br>

4. validate

데이터베이스 테이블과 엔티티 정보를 비교후 차이가 있으면 경고 후 어플리케이션을 시행하지 않는다.

이는 위의 기능들과 다르게 **변경을 가하지 않는다**.

그렇기 때문에, 실제 개발환경에서 유용하다.

<br>
<br>

5. none

자동 생성기능을 사용하지 않겠다는 뜻이다.

<br><br>

## 결론

---

1. 엔티티를 실제 테이블 정보로 매핑하기 위해 사용하는 어노테이션이 있다.
2. 키 생성 전략은 데이터베이스 종류마다 차이가 있어서 자동 생성전략일때 차이가 있다.
3. 흔히 사용하는 MySql의 Identity 전략은 bulk insert를 진행할때 n번의 호출이 될 수 있다.

<br><br><br>












